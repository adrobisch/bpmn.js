// Generated by uRequire v0.6.15 - template: 'combined' 
// Combined template optimized with RequireJS/r.js v2.1.13 & almond.
(function (global, window){
  
var __isAMD = !!(typeof define === 'function' && define.amd),
    __isNode = (typeof exports === 'object'),
    __isWeb = !__isNode;

  var __nodeRequire = (__isNode ? require :
      function(dep){
        throw new Error("uRequire detected missing dependency: '" + dep + "' - in a non-nodejs runtime. All it's binding variables were 'undefined'.")
      });
var bundleFactory = function(sax, Kinetic, declare, l, array, Deferred, topic) {/**
 * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                name = baseParts.concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("almond", function(){});

define('dojo/_base/declare',[],function () {
  if (__isNode) {
  return __nodeRequire('dojo/_base/declare');
} else {
  return (typeof declare !== 'undefined') ? declare : __nodeRequire('dojo/_base/declare')
}
});
define('dojo/_base/lang',[],function () {
  if (__isNode) {
  return __nodeRequire('dojo/_base/lang');
} else {
  return (typeof l !== 'undefined') ? l : __nodeRequire('dojo/_base/lang')
}
});
define('bpmn/Clazz',['require', 'exports', 'module', 'dojo/_base/declare', 'dojo/_base/lang'], function (require, exports, module, declare, l) {
  

var clazz = {
      constructor: function (obj) {
        this.text = null;
        this.reference = {};
        this.attribute = {};
        if (obj) {
          l.mixin(this, obj);
        }
      },
      addReference: function (ref) {
        this.reference[ref.name] = ref;
        var name = this.__internalFieldName(ref.name);
        if (ref.containment === true) {
          this[name] = [];
        } else {
          this[name] = null;
        }
        this[ref.name] = function (newValue) {
          return this.accessor(ref.name, newValue);
        };
      },
      addAttribute: function (attr) {
        this.attribute[attr.name] = attr;
        this[attr.name] = function (newValue) {
          return this.accessor(attr.name, newValue);
        };
      },
      accessor: function (field, newValue) {
        var name = this.__internalFieldName(field);
        if (newValue != null && newValue != undefined) {
          this[name] = newValue;
        }
        return this[name];
      },
      __internalFieldName: function (field) {
        return "_" + field;
      },
      init: function () {
      },
      setText: function (text) {
        this.text = text;
      }
    };
  return declare("bpmn.Clazz", null, clazz);


});
define('bpmn/util/Index',['require', 'exports', 'module', 'dojo/_base/declare'], function (require, exports, module, declare) {
  

var index = {
      constructor: function () {
        this._ = {};
      },
      add: function (key, value) {
        this._[key] = value;
      },
      addArray: function (key, value) {
        if (!this._[key]) {
          this._[key] = [];
        }
        this._[key].push(value);
      },
      addMap: function (key, property, value) {
        if (!this._[key]) {
          this._[key] = {};
        }
        this._[key][property] = value;
      },
      item: function (key) {
        return this._[key];
      }
    };
  return declare("bpmn.util.Index", null, index);


});
define('bpmn/BaseElement',['require', 'exports', 'module', 'dojo/_base/declare', './Clazz', './util/Index'], function (require, exports, module, declare, Clazz) {
  

var baseElement = {
      constructor: function () {
        this.addReference({
          name: "documentation",
          type: function Documentation() {
          }
        });
        this.addAttribute({
          name: "id",
          type: String
        });
        this.addAttribute({
          name: "name",
          type: String
        });
        var uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
            return v.toString(16);
          });
        this.id(uuid);
      },
      init: function () {
        this._definitions.index.add(this.id(), this);
        this._definitions.index.addMap(this.declaredClass, this.id(), this);
      }
    };
  return declare("bpmn.BaseElement", Clazz, baseElement);


});
define('bpmn/CallableElement',['require', 'exports', 'module', 'dojo/_base/declare', './BaseElement'], function (require, exports, module, declare, BaseElement) {
  

var callableElement = {
      constructor: function () {
        this.addAttribute({
          name: "name",
          type: String
        });
      }
    };
  return declare("bpmn.CallableElement", BaseElement, callableElement);


});
define('bpmn/Package',['require', 'exports', 'module', 'dojo/_base/declare'], function (require, exports, module, declare) {
  

var p = {
      tagMap: {},
      constructor: function () {
      },
      registerClass: function (newClass) {
        var tag = newClass.prototype.tag;
        if (tag) {
          this.tagMap[tag.toLowerCase()] = newClass;
        }
        return newClass;
      }
    };
  var Package = declare("bpmn.Package", null, p);
  return window.bpmnPackage = new Package();


});
define('bpmn/FlowElement',['require', 'exports', 'module', 'dojo/_base/declare', './BaseElement', './Package'], function (require, exports, module, declare, BaseElement, Package) {
  

var flowElement = {
      tag: "flowElement",
      constructor: function () {
      },
      getDiagramElement: function () {
        return this._definitions.index.item(this.id() + ":di");
      },
      getBounds: function () {
        return this.getDiagramElement().bounds();
      },
      getWaypoints: function () {
        return this.getDiagramElement().waypoints();
      }
    };
  return Package.registerClass(declare("bpmn.FlowElement", BaseElement, flowElement));


});
define('bpmn/FlowElementsContainer',['require', 'exports', 'module', 'dojo/_base/declare', './BaseElement', './FlowElement'], function (require, exports, module, declare, BaseElement, FlowElement) {
  

var flowElementsContainer = {
      constructor: function () {
        this.addReference({
          name: "flowElements",
          containment: true,
          type: FlowElement
        });
      }
    };
  return declare("bpmn.FlowElementsContainer", BaseElement, flowElementsContainer);


});
define('bpmn/Process',['require', 'exports', 'module', 'dojo/_base/declare', './CallableElement', './FlowElementsContainer', './Package'], function (require, exports, module, declare, CallableElement, FlowElementsContainer, Package) {
  

var process = {
      tag: "process",
      constructor: function () {
        this.addAttribute({
          name: "isExecutable",
          containment: true,
          type: "boolean"
        });
      }
    };
  return Package.registerClass(declare("bpmn.Process", [
    FlowElementsContainer,
    CallableElement
  ], process));


});
define('bpmn/Collaboration',['require', 'exports', 'module', 'dojo/_base/declare', './Package'], function (require, exports, module, declare, Package) {
  

var collaboration = {
      tag: "collaboration",
      constructor: function () {
      }
    };
  return Package.registerClass(declare("bpmn.Collaboration", null, collaboration));


});
define('bpmn/di/DiagramElement',['require', 'exports', 'module', 'dojo/_base/declare', '../Clazz', '../Package'], function (require, exports, module, declare, Clazz, Package) {
  

var DiagramElement = {
      tag: "diagramElement",
      constructor: function () {
        this.addAttribute({
          name: "id",
          type: String
        });
        this.addAttribute({
          name: "bpmnElement",
          type: String
        });
      },
      init: function () {
        this._definitions.index.add(this.bpmnElement() + ":di", this);
      }
    };
  return Package.registerClass(declare("bpmn.DiagramElement", Clazz, DiagramElement));


});
define('bpmn/di/Bounds',['require', 'exports', 'module', 'dojo/_base/declare', '../Clazz', '../Package'], function (require, exports, module, declare, Clazz, Package) {
  

var Bounds = {
      tag: "Bounds",
      constructor: function () {
        this.addAttribute({
          name: "x",
          type: "float"
        });
        this.addAttribute({
          name: "y",
          type: "float"
        });
        this.addAttribute({
          name: "width",
          type: "float"
        });
        this.addAttribute({
          name: "height",
          type: "float"
        });
      }
    };
  return Package.registerClass(declare("bpmn.Bounds", Clazz, Bounds));


});
define('bpmn/di/BPMNShape',['require', 'exports', 'module', 'dojo/_base/declare', './DiagramElement', './Bounds', '../Package'], function (require, exports, module, declare, DiagramElement, Bounds, Package) {
  

var BPMNShape = {
      tag: "BPMNShape",
      constructor: function () {
        this.addReference({
          name: "bounds",
          type: Bounds
        });
      }
    };
  return Package.registerClass(declare("bpmn.BPMNShape", DiagramElement, BPMNShape));


});
define('bpmn/di/Waypoint',['require', 'exports', 'module', 'dojo/_base/declare', '../Clazz', '../Package'], function (require, exports, module, declare, Clazz, Package) {
  

var Waypoint = {
      tag: "waypoint",
      constructor: function () {
        this.addAttribute({
          name: "x",
          type: "float"
        });
        this.addAttribute({
          name: "y",
          type: "float"
        });
      },
      __internalFieldName: function (field) {
        return field;
      }
    };
  return Package.registerClass(declare("bpmn.Waypoint", Clazz, Waypoint));


});
define('bpmn/di/BPMNEdge',['require', 'exports', 'module', 'dojo/_base/declare', './DiagramElement', './Waypoint', '../Package'], function (require, exports, module, declare, DiagramElement, Waypoint, Package) {
  

var BPMNEdge = {
      tag: "BPMNEdge",
      constructor: function () {
        this.addReference({
          name: "waypoints",
          containment: true,
          type: Waypoint
        });
      }
    };
  return Package.registerClass(declare("bpmn.BPMNEdge", DiagramElement, BPMNEdge));


});
define('bpmn/di/BPMNPlane',['require', 'exports', 'module', 'dojo/_base/declare', '../Clazz', '../Package', './BPMNShape', './BPMNEdge', './DiagramElement'], function (require, exports, module, declare, Clazz, Package, Shape, Edge, DiagramElement) {
  

var BPMNPlane = {
      tag: "BPMNPlane",
      constructor: function () {
        this.addReference({
          name: "diagramElements",
          containment: true,
          type: DiagramElement
        });
      }
    };
  return Package.registerClass(declare("bpmn.BPMNPlane", Clazz, BPMNPlane));


});
define('bpmn/di/BPMNDiagram',['require', 'exports', 'module', 'dojo/_base/declare', '../Clazz', './BPMNPlane', '../Package'], function (require, exports, module, declare, Clazz, BPMNPlane, Package) {
  

var BPMNDiagram = {
      tag: "BPMNDiagram",
      constructor: function () {
        this.addReference({
          name: "plane",
          type: BPMNPlane
        });
      }
    };
  return Package.registerClass(declare("bpmn.BPMNDiagram", Clazz, BPMNDiagram));


});
define('bpmn/FlowNode',['require', 'exports', 'module', 'dojo/_base/declare', './FlowElement', './Package'], function (require, exports, module, declare, FlowElement, Package) {
  

var flowNode = {
      tag: "flowNode",
      constructor: function () {
      },
      incoming: function () {
        var incoming = this._definitions.index.item("target:" + this.id());
        return incoming ? incoming : [];
      },
      outgoing: function () {
        var outgoing = this._definitions.index.item("source:" + this.id());
        return outgoing ? outgoing : [];
      }
    };
  return Package.registerClass(declare("bpmn.FlowNode", FlowElement, flowNode));


});
define('bpmn/Event',['require', 'exports', 'module', 'dojo/_base/declare', './FlowNode', './Package'], function (require, exports, module, declare, FlowNode, Package) {
  

var event = {
      tag: "event",
      constructor: function () {
      }
    };
  return Package.registerClass(declare("bpmn.Event", FlowNode, event));


});
define('bpmn/CatchEvent',['require', 'exports', 'module', 'dojo/_base/declare', './Event', './Package'], function (require, exports, module, declare, Event, Package) {
  

var catchEvent = {
      tag: "catchEvent",
      constructor: function () {
      }
    };
  return Package.registerClass(declare("bpmn.CatchEvent", Event, catchEvent));


});
define('bpmn/StartEvent',['require', 'exports', 'module', 'dojo/_base/declare', './CatchEvent', './Package'], function (require, exports, module, declare, CatchEvent, Package) {
  

var startEvent = {
      tag: "startEvent",
      constructor: function () {
      }
    };
  return Package.registerClass(declare("bpmn.StartEvent", CatchEvent, startEvent));


});
define('bpmn/ThrowEvent',['require', 'exports', 'module', 'dojo/_base/declare', './Event', './Package'], function (require, exports, module, declare, Event, Package) {
  

var throwEvent = {
      tag: "throwEvent",
      constructor: function () {
      }
    };
  return Package.registerClass(declare("bpmn.ThrowEvent", Event, throwEvent));


});
define('bpmn/EndEvent',['require', 'exports', 'module', 'dojo/_base/declare', './ThrowEvent', './Package'], function (require, exports, module, declare, ThrowEvent, Package) {
  

var endEvent = {
      tag: "endEvent",
      constructor: function () {
      }
    };
  return Package.registerClass(declare("bpmn.EndEvent", ThrowEvent, endEvent));


});
define('bpmn/BoundaryEvent',['require', 'exports', 'module', 'dojo/_base/declare', './CatchEvent', './Package'], function (require, exports, module, declare, CatchEvent, Package) {
  

var boundaryEvent = {
      tag: "boundaryEvent",
      constructor: function () {
      }
    };
  return Package.registerClass(declare("bpmn.BoundaryEvent", CatchEvent, boundaryEvent));


});
define('bpmn/Activity',['require', 'exports', 'module', 'dojo/_base/declare', './FlowNode', './Package'], function (require, exports, module, declare, FlowNode, Package) {
  

var activity = {
      tag: "activity",
      constructor: function () {
      }
    };
  return Package.registerClass(declare("bpmn.Activity", FlowNode, activity));


});
define('bpmn/Task',['require', 'exports', 'module', 'dojo/_base/declare', './Activity', './Package'], function (require, exports, module, declare, Activity, Package) {
  

var task = {
      tag: "task",
      constructor: function () {
      }
    };
  return Package.registerClass(declare("bpmn.Task", Activity, task));


});
define('bpmn/UserTask',['require', 'exports', 'module', 'dojo/_base/declare', './Task', './Package'], function (require, exports, module, declare, Task, Package) {
  

var userTask = {
      tag: "userTask",
      constructor: function () {
      }
    };
  return Package.registerClass(declare("bpmn.UserTask", Task, userTask));


});
define('bpmn/ServiceTask',['require', 'exports', 'module', 'dojo/_base/declare', './Task', './Package'], function (require, exports, module, declare, Task, Package) {
  

var serviceTask = {
      tag: "serviceTask",
      constructor: function () {
      }
    };
  return Package.registerClass(declare("bpmn.ServiceTask", Task, serviceTask));


});
define('bpmn/BusinessRuleTask',['require', 'exports', 'module', 'dojo/_base/declare', './Task', './Package'], function (require, exports, module, declare, Task, Package) {
  

var businessRuleTask = {
      tag: "businessRuleTask",
      constructor: function () {
      }
    };
  return Package.registerClass(declare("bpmn.BusinessRuleTask", Task, businessRuleTask));


});
define('bpmn/ReceiveTask',['require', 'exports', 'module', 'dojo/_base/declare', './Task', './Package'], function (require, exports, module, declare, Task, Package) {
  

var receiveTask = {
      tag: "receiveTask",
      constructor: function () {
      }
    };
  return Package.registerClass(declare("bpmn.ReceiveTask", Task, receiveTask));


});
define('bpmn/SubProcess',['require', 'exports', 'module', 'dojo/_base/declare', './Activity', './FlowElementsContainer', './Package'], function (require, exports, module, declare, Activity, FlowElementsContainer, Package) {
  

var subProcess = {
      tag: "subProcess",
      constructor: function () {
      }
    };
  return Package.registerClass(declare("bpmn.SubProcess", [
    Activity,
    FlowElementsContainer
  ], subProcess));


});
define('bpmn/Gateway',['require', 'exports', 'module', 'dojo/_base/declare', './FlowNode', './Package'], function (require, exports, module, declare, FlowNode, Package) {
  

var gateway = {
      tag: "gateway",
      constructor: function () {
      }
    };
  return Package.registerClass(declare("bpmn.Gateway", FlowNode, gateway));


});
define('bpmn/ExclusiveGateway',['require', 'exports', 'module', 'dojo/_base/declare', './Gateway', './Package'], function (require, exports, module, declare, Gateway, Package) {
  

var exclusiveGateway = {
      tag: "exclusiveGateway",
      constructor: function () {
        this.addAttribute({
          name: "default",
          type: String
        });
      },
      getDefault: function () {
        return this._definitions.index.item(this.default());
      }
    };
  return Package.registerClass(declare("bpmn.ExclusiveGateway", Gateway, exclusiveGateway));


});
define('bpmn/ParallelGateway',['require', 'exports', 'module', 'dojo/_base/declare', './Gateway', './Package'], function (require, exports, module, declare, Gateway, Package) {
  

var parallelGateway = {
      tag: "parallelGateway",
      constructor: function () {
      }
    };
  return Package.registerClass(declare("bpmn.ParallelGateway", Gateway, parallelGateway));


});
define('bpmn/ConditionExpression',['require', 'exports', 'module', 'dojo/_base/declare', './BaseElement', './Package'], function (require, exports, module, declare, BaseElement, Package) {
  

var conditionExpression = {
      tag: "conditionExpression",
      constructor: function () {
      }
    };
  return Package.registerClass(declare("bpmn.ConditionExpression", BaseElement, conditionExpression));


});
define('bpmn/SequenceFlow',['require', 'exports', 'module', 'dojo/_base/declare', './FlowElement', './ConditionExpression', './Package'], function (require, exports, module, declare, FlowElement, ConditionExpression, Package) {
  

var sequenceFlow = {
      tag: "sequenceFlow",
      constructor: function () {
        this.addAttribute({
          name: "sourceRef",
          type: String
        });
        this.addAttribute({
          name: "targetRef",
          type: String
        });
        this.addReference({
          name: "conditionExpression",
          type: ConditionExpression
        });
      },
      getSourceRef: function () {
        return this._definitions.index.item(this._sourceRef);
      },
      getTargetRef: function () {
        return this._definitions.index.item(this._targetRef);
      },
      init: function () {
        this.inherited(arguments);
        this._definitions.index.addArray("target:" + this.targetRef(), this);
        this._definitions.index.addArray("source:" + this.sourceRef(), this);
      }
    };
  return Package.registerClass(declare("bpmn.SequenceFlow", FlowElement, sequenceFlow));


});
define('bpmn/Definitions',['require', 'exports', 'module', 'dojo/_base/declare', './BaseElement', './Process', './Collaboration', './di/BPMNDiagram', './util/Index', './StartEvent', './EndEvent', './BoundaryEvent', './UserTask', './ServiceTask', './BusinessRuleTask', './ReceiveTask', './SubProcess', './ExclusiveGateway', './ParallelGateway', './SequenceFlow'], function (require, exports, module, declare, BaseElement, Process, Collaboration, BPMNDiagram, Index) {
  

var definitions = {
      tag: "definitions",
      constructor: function () {
        this.addReference({
          name: "collaboration",
          type: Collaboration
        });
        this.addReference({
          name: "process",
          containment: true,
          type: Process
        });
        this.addReference({
          name: "bpmnDiagram",
          type: BPMNDiagram
        });
        this.index = new Index();
      }
    };
  return declare("bpmn.Defintions", BaseElement, definitions);


});
define('bpmn/execution/TokenStore',['require', 'exports', 'module', 'dojo/_base/declare', 'dojo/_base/lang'], function (require, exports, module, declare, l) {
  

var tokenStore = {
      constructor: function (tokenMap) {
        this.tokenMap = tokenMap ? tokenMap : {};
      },
      add: function (id, token) {
        if (!this.tokenMap[id]) {
          this.tokenMap[id] = [];
        }
        this.tokenMap[id].push(token);
      },
      drop: function (id, count) {
        if (this.tokenMap[id]) {
          for (var c = 0; c < count; c++) {
            this.tokenMap[id].pop();
          }
        }
      },
      query: function (id) {
        return this.tokenMap[id] ? this.tokenMap[id] : [];
      },
      count: function () {
        var result = 0;
        for (var key in this.tokenMap) {
          result += this.tokenMap[key].length;
        }
        return result;
      }
    };
  return declare("bpmn.TokenStore", null, tokenStore);


});
define('dojo/_base/array',[],function () {
  if (__isNode) {
  return __nodeRequire('dojo/_base/array');
} else {
  return (typeof array !== 'undefined') ? array : __nodeRequire('dojo/_base/array')
}
});
define('dojo/Deferred',[],function () {
  if (__isNode) {
  return __nodeRequire('dojo/Deferred');
} else {
  return (typeof Deferred !== 'undefined') ? Deferred : __nodeRequire('dojo/Deferred')
}
});
define('dojo/topic',[],function () {
  if (__isNode) {
  return __nodeRequire('dojo/topic');
} else {
  return (typeof topic !== 'undefined') ? topic : __nodeRequire('dojo/topic')
}
});
define('bpmn/execution/Instance',['require', 'exports', 'module', './TokenStore', 'dojo/_base/declare', 'dojo/_base/array', 'dojo/_base/lang', 'dojo/Deferred', 'dojo/topic'], function (require, exports, module, TokenStore, declare, array, l, Deferred, topic) {
  

var instance = {
      constructor: function (definitions, configuration, tokenMap, variables) {
        this.definitions = definitions;
        this.configuration = configuration;
        this.tokenStore = new TokenStore(tokenMap);
        this.variables = variables ? variables : {};
        this.behaviours["bpmn.StartEvent"] = this.behaviours["takeAll"];
        this.behaviours["bpmn.EndEvent"] = this.behaviours["takeNone"];
        this.behaviours["bpmn.UserTask"] = this.behaviours["takeNone"];
        this.behaviours["bpmn.ServiceTask"] = this.behaviours["takeAll"];
        this.behaviours["bpmn.ExclusiveGateway"] = this.behaviours["xor"];
        this.behaviours["bpmn.ParallelGateway"] = this.behaviours["and"];
      },
      behaviours: {
        "takeAll": function (element) {
          this.dropToken(element.id(), this.tokenStore);
          return element.outgoing();
        },
        "takeNone": function (element) {
          return [];
        },
        "xor": function (element) {
          this.dropToken(element.id(), this.tokenStore);
          if (element.outgoing().length == 1) {
            return element.outgoing();
          }
          var transition = null;
          array.map(element.outgoing(), function (outgoing) {
            var flowConfig = this.configuration[outgoing.id()];
            if (!transition && flowConfig && flowConfig(this)) {
              transition = outgoing;
            }
          }, this);
          if (!transition && !element.getDefault()) {
            throw new Error("No transition evaluated to true and no default defined");
          }
          return transition;
        },
        "and": function (element) {
          var isActive = true;
          var tokens = this.tokenStore.query(element.id());
          var fromMap = {};
          if (element.incoming().length == 1) {
            return l.hitch(this, this.behaviours.takeAll)(element);
          }
          for (var index = 0; index < tokens.length; index++) {
            var token = tokens[index];
            fromMap[token.from] = token;
          }
          var activeTransitions = [];
          array.map(element.incoming(), function (incoming) {
            if (!fromMap[incoming.id()]) {
              isActive = false;
            } else {
              activeTransitions.push(incoming);
            }
          }, this);
          if (isActive) {
            array.map(activeTransitions, function (t) {
              l.hitch(this, this.dropToken)(t.sourceRef(), this.tokenStore);
            }, this);
            return l.hitch(this, this.behaviours.takeAll)(element);
          } else {
            return [];
          }
        }
      },
      dropToken: function (id, tokenStore, count) {
        if (tokenStore.query(id).length > 0) {
          tokenStore.drop(id, count ? count : 1);
        }
      },
      copyVariables: function (variables) {
        if (variables) {
          for (var index in variables) {
            this.variables[index] = variables[index];
          }
        }
      },
      start: function (startId, variables) {
        this.tokenStore.add(startId, { from: null });
        return this.trigger(startId, variables);
      },
      trigger: function (elementId, variables, behaviour, path) {
        console.log("trigger", elementId);
        var deferred = new Deferred();
        var path = path ? path : new Deferred();
        this.copyVariables(variables);
        var node = this.definitions.index.item(elementId);
        var nodeBehaviour = behaviour ? this.behaviours[behaviour] : this.behaviours[node.declaredClass];
        var transitions = [].concat(l.hitch(this, nodeBehaviour)(node, this.tokenStore));
        console.log("next", transitions);
        if (transitions.length > 0 && this.configuration.leave) {
          this.configuration.leave(node);
          topic.publish("flow:leave:" + node.id(), node);
        }
        if (transitions.length == 0) {
          path.resolve();
        }
        transitions.map(function (transition) {
          this.tokenStore.add(transition.targetRef(), { from: transition.id() });
          var pubPath = "flow:enter:" + transition.targetRef();
          topic.publish(pubPath, transition.getTargetRef());
          if (this.configuration.enter) {
            this.configuration.enter(transition.getTargetRef());
          }
          var self = this;
          deferred.then(function () {
            console.log("then for", transition.id());
            self.trigger(transition.targetRef(), null, null, path);
          });
        }, this);
        if (this.configuration[elementId] && this.configuration[elementId]) {
          this.configuration[elementId]({
            instance: this,
            promise: deferred
          });
        } else {
          console.log("resolving", elementId, this.tokenStore.tokenMap);
          deferred.resolve();
        }
        return path;
      }
    };
  return declare("bpmn.Instance", null, instance);


});
define('sax',[],function () {
  if (__isNode) {
  return __nodeRequire('sax');
} else {
  return (typeof sax !== 'undefined') ? sax : __nodeRequire('sax')
}
});
define('bpmn/util/Serializer',['require', 'exports', 'module', 'dojo/_base/declare', '../Package', '../Definitions', '../BaseElement', 'sax'], function (require, exports, module, declare, Package, Definitions, BaseElement) {
  

var serializer = {
      constructor: function () {
      },
      fromXML: function (xmlString) {
        if (!xmlString) {
          return;
        }
        var attr = function (attrName, node, bpmnObj, type) {
          if (node.attributes[attrName]) {
            var value = node.attributes[attrName].value;
            if (type == "float") {
              value = parseFloat(value);
            }
            if (type == "boolean") {
              value = value.toLowerCase() == "true";
            }
            if (type == "integer") {
              value = parseInt(value);
            }
            bpmnObj[attrName](value);
          }
        };
        var parser = sax.parser(true, {
            xmlns: true,
            lowercase: true,
            trim: true
          });
        parser.stack = [];
        Array.prototype.peek = function () {
          return this.length == 0 ? null : this[this.length - 1];
        };
        var openTag = {
            "definitions": function (node) {
              parser.definitions = new Definitions();
              parser.stack.push(parser.definitions);
            },
            "default": function (node) {
              var parent = parser.stack.peek();
              var tagLookup = node.local.toLowerCase();
              var newRef = Package.tagMap[tagLookup] ? Package.tagMap[tagLookup]() : new BaseElement();
              parser.stack.push(newRef);
              newRef._definitions = parser.definitions;
              for (var attributeName in newRef.attribute) {
                attr(attributeName, node, newRef, newRef.attribute[attributeName].type);
              }
              var refFound = null;
              for (var index in parent.reference) {
                var ref = parent.reference[index];
                if (newRef.isInstanceOf(ref.type)) {
                  refFound = ref;
                  break;
                }
              }
              newRef.init();
              if (refFound && refFound.containment === true) {
                parent[refFound.name]().push(newRef);
              } else if (refFound) {
                parent[refFound.name](newRef);
              }
            }
          };
        parser.onerror = function (e) {
          console.log("error", e);
        };
        parser.onopentag = function (node) {
          if (openTag[node.local]) {
            openTag[node.local](node);
          } else {
            openTag["default"](node);
          }
        };
        parser.onclosetag = function (node) {
          parser.stack.pop();
        };
        parser.ontext = function (t) {
          parser.stack.peek().setText(t);
        };
        parser.onend = function () {
        };
        parser.write(xmlString).close();
        return parser.definitions;
      }
    };
  return declare("bpmn.util.Serializer", null, serializer);


});
define('kinetic',[],function () {
  if (__isNode) {
  return __nodeRequire('kinetic');
} else {
  return (typeof Kinetic !== 'undefined') ? Kinetic : __nodeRequire('kinetic')
}
});
define('bpmn/util/diagram/Canvas',['require', 'exports', 'module', 'kinetic'], function (require, exports, module, Kinetic) {
  

var Canvas = function Canvas(options) {
    this.scale = options.scale;
    var stage = this.stage = new Kinetic.Stage({
        container: options.container,
        width: options.width ? options.width : 500,
        height: options.height ? options.height : 500
      });
    stage.scale({
      x: this.scale,
      y: this.scale
    });
    this.shapeLayer = new Kinetic.Layer();
    this.connectionsLayer = new Kinetic.Layer();
    this.labelLayer = new Kinetic.Layer();
    stage.add(this.shapeLayer);
    stage.add(this.connectionsLayer);
    stage.add(this.labelLayer);
    this.createGroup = function (group) {
      return new Kinetic.Group(group);
    };
    this.createRect = function (rect) {
      return new Kinetic.Rect(rect);
    };
    this.createCircle = function (circle) {
      return new Kinetic.Circle(circle);
    };
    this.createLine = function (line) {
      return new Kinetic.Line(line);
    };
    this.createText = function (text) {
      return new Kinetic.Text(text);
    };
    this.createPolygon = function (polygon) {
      polygon.closed = true;
      return new Kinetic.Line(polygon);
    };
    this.createPath = function (path) {
      return new Kinetic.Path(path);
    };
    this.createArrowLine = function (points, lineOptions, size) {
      var headlen = size ? size : 6;
      var lastx = points[points.length - 2];
      var lasty = points[points.length - 1];
      var secondlastx = points[points.length - 4];
      var secondlasty = points[points.length - 3];
      var angle = Math.atan2(lasty - secondlasty, lastx - secondlastx);
      lineOptions.points = points.concat([
        lastx - headlen * Math.cos(angle - Math.PI / 6),
        lasty - headlen * Math.sin(angle - Math.PI / 6),
        lastx,
        lasty,
        lastx - headlen * Math.cos(angle + Math.PI / 6),
        lasty - headlen * Math.sin(angle + Math.PI / 6)
      ]);
      var line = new Kinetic.Line(lineOptions);
      return line;
    };
    this.expandCanvasIfNeeded = function (shape) {
      var buffer = 10;
      var x = shape.getX(), y = shape.getY(), width = shape.getWidth(), height = shape.getHeight();
      if ((x + width) * this.scale > this.stage.getWidth()) {
        this.stage.setWidth((x + width + buffer) * this.scale);
      }
      if ((y + height) * this.scale > this.stage.getHeight()) {
        this.stage.setHeight((y + height + buffer) * this.scale);
      }
    };
  };
  return Canvas;


});
define('bpmn/editor/ActivityRenderer',['require','exports','module'],function (require, exports, module) {
  

var ActivityRenderer = function (renderer) {
    this.markerPaths = {
      "bpmn.ServiceTask": "m 22.701284,14.663851 c 0.432742,0 0.835353,-0.363368 0.894226,-0.807377 0,0 0.08274,-0.624013 0.08274,-1.366108 0,-0.742094 -0.08274,-1.366107 -0.08274,-1.366107 -0.05909,-0.444249 -0.461484,-0.807376 -0.894226,-0.807376 h -2.236261 c -0.432975,0 -0.882637,-0.285846 -0.998992,-0.6350536 -0.116355,-0.3492066 -0.276519,-1.4695496 0.02967,-1.7863558 L 21.076473,6.2586397 C 21.382428,5.9415935 21.40607,5.4006221 21.128856,5.0562152 L 19.269014,3.1299359 C 18.936402,2.8426498 18.414191,2.8671302 18.107771,3.1841824 L 16.526998,4.8210152 C 16.221042,5.1380613 15.710883,5.2657441 15.394032,5.1049407 15.076952,4.9441373 14.18852,4.2658838 14.18852,3.8175543 V 1.501988 c 0,-0.4483294 -0.350922,-0.86497745 -0.779725,-0.92617905 0,0 -0.60264,-0.085927 -1.319319,-0.085927 -0.716679,0 -1.319319,0.085927 -1.319319,0.085927 -0.429034,0.06096 -0.7799559,0.47784965 -0.7799559,0.92617905 v 2.3155663 c 0,0.4483295 -0.275824,0.9136994 -0.6133031,1.0344211 C 9.0394192,4.9724583 7.9576789,5.1383013 7.6514912,4.8212576 L 6.0707181,3.1844175 C 5.7645304,2.8673702 5.2420872,2.8428899 4.9097076,3.1299359 L 3.0496339,5.0559751 C 2.7721873,5.4003821 2.7958294,5.9413535 3.1020167,6.2583996 L 4.682558,7.8952336 C 4.9887458,8.2122798 5.1122872,8.7402903 4.9567595,9.0683769 4.8012323,9.3964637 4.14644,10.316643 3.7134658,10.316643 H 1.4774369 c -0.4329742,0 -0.83535274,0.363367 -0.89445788,0.807376 0,0 -0.082979,0.624013 -0.082979,1.366107 0,0.742335 0.082979,1.366108 0.082979,1.366108 0.0588733,0.444249 0.46148368,0.807376 0.89445788,0.807376 h 2.2362607 c 0.4329742,0 0.882405,0.285607 0.9987611,0.635054 0.116356,0.349206 0.2765193,1.46931 -0.029668,1.786356 l -1.5805412,1.636594 c -0.3061877,0.317046 -0.3298298,0.858017 -0.052384,1.202424 l 1.859842,1.926279 c 0.3326113,0.287047 0.8548228,0.262806 1.1610105,-0.05425 l 1.5807733,-1.636829 c 0.3061877,-0.316806 0.8161146,-0.444729 1.1331963,-0.283925 0.3170817,0.160802 1.2055136,0.839057 1.2055136,1.287386 v 2.315567 c 0,0.448089 0.3509218,0.864976 0.7799558,0.925938 0,0 0.602408,0.08568 1.319319,0.08568 0.71691,0 1.319319,-0.08568 1.319319,-0.08568 0.429035,-0.06119 0.779725,-0.477849 0.779725,-0.925938 v -2.315567 c 0,-0.448329 0.275825,-0.913939 0.613303,-1.034421 0.337479,-0.120482 1.419219,-0.286086 1.725407,0.03071 l 1.580541,1.636833 c 0.306188,0.316807 0.828631,0.341288 1.161243,0.05425 l 1.859842,-1.925559 c 0.277214,-0.344407 0.253804,-0.885138 -0.05262,-1.202424 l -1.58054,-1.636586 c -0.306188,-0.317046 -0.42973,-0.845056 -0.274202,-1.173383 0.155296,-0.328327 0.81032,-1.248266 1.243294,-1.248266 h 2.236492 z m -10.612039,2.218844 c -2.342882,0 -4.2421275,-1.966359 -4.2421275,-4.392569 0,-2.425728 1.8992455,-4.3925682 4.2421275,-4.3925682 2.342882,0 4.242127,1.9666002 4.242127,4.3925682 0,2.42597 -1.899245,4.392569 -4.242127,4.392569 z",
      "bpmn.UserTask": "M 12.253681,11.77491 C 11.634895,10.657313 10.877364,9.7523027 10.117807,9.1196049 9.2316574,9.7684998 8.152074,10.163303 6.9752673,10.163303 5.7964351,10.163303 4.715839,9.7674875 3.8307021,9.1196049 3.0711453,9.7523027 2.313614,10.657313 1.6928029,11.77491 c -1.44011956,2.594568 -1.59810737,5.255948 -0.3544598,5.946348 0.5570083,0.310781 1.1413607,0.07896 1.7449552,-0.502109 -0.106338,0.589168 -0.1681153,1.22794 -0.1681153,1.896068 0,2.968112 1.1535136,5.372364 2.5754039,5.372364 0.8567801,0 1.2811192,-0.875654 1.4846804,-2.215961 0.2035612,1.340307 0.6279003,2.215961 1.4816421,2.215961 1.4239158,0 2.5774296,-2.404252 2.5774296,-5.372364 0,-0.668128 -0.06178,-1.3069 -0.170141,-1.896068 0.60562,0.581069 1.18896,0.81289 1.746981,0.502109 1.243647,-0.6904 1.082621,-3.35178 -0.357498,-5.946348 z M 6.9742546,9.1509867 c 2.3920975,0 4.3325124,-1.9395984 4.3325124,-4.3317023 0,-2.3921039 -1.9404149,-4.33170228 -4.3325124,-4.33170228 -2.3931103,0 -4.3345375,1.93959838 -4.3345375,4.33170228 0,2.3921039 1.9414272,4.3317023 4.3345375,4.3317023 z",
      "bpmn.BusinessRuleTask": "M 0.49999997,0.68485673 V 3.8369982 H 24.501049 V 0.68485673 H 0.49999997 z m 0,17.05141427 H 24.501049 V 14.58413 H 0.49999997 v 3.152141 z m 0,-6.949637 H 24.501049 V 7.6344932 H 0.49999997 v 3.1521408 z m 0,13.898223 H 24.501049 V 21.532715 H 0.49999997 v 3.152142 z",
      "bpmn.ReceiveTask": "M 1.7164479,0.59270005 9.5482144,6.784475 17.408905,0.54332386 z M 0.70000001,1.254341 l 0,11.06027 17.69642899,0 0,-11.06027 -8.8482146,6.6361608 z"
    };
    this.createRectangle = function (bounds) {
      var cornerRadius = renderer.skin()["activity_corner_radius"];
      var rect = renderer.canvas.createRect({
          width: bounds.width(),
          height: bounds.height(),
          "cornerRadius": cornerRadius,
          stroke: renderer.skin()["activity_stroke"],
          fill: renderer.skin()["activity_fill"],
          strokeWidth: 2
        });
      return rect;
    };
    this.getPathForActivityType = function (activity) {
      return this.markerPaths[activity.declaredClass];
    };
    this.createMarker = function (pathForType) {
      var activityMarker = renderer.canvas.createPath({
          x: 3,
          y: 3,
          data: pathForType,
          stroke: renderer.skin()["activity_stroke"],
          fill: renderer.skin()["activity_fill"],
          scale: 0.6
        });
      return activityMarker;
    };
    this.render = function (activity, group) {
      var bounds = activity.getBounds();
      var rect = this.createRectangle(bounds);
      var pathForType = this.getPathForActivityType(activity);
      var activityMarker = this.createMarker(pathForType);
      group.add(rect);
      group.add(activityMarker);
      return group;
    };
  };
  return ActivityRenderer;


});
define('bpmn/editor/EventRenderer',['require','exports','module'],function (require, exports, module) {
  

var EventRenderer = function () {
    this.render = function (event, group) {
      var bounds = event.getBounds();
      var circle = this.canvas.createCircle({
          width: bounds.width(),
          height: bounds.height(),
          stroke: this.skin()["event_stroke"],
          strokeWidth: 2,
          draggable: true
        });
      group.add(circle);
      return group;
    };
  };
  return EventRenderer;


});
define('bpmn/editor/GatewayRenderer',['require','exports','module'],function (require, exports, module) {
  

var GatewayRenderer = function () {
    this.render = function (gateway, group) {
      var bounds = gateway.getBounds();
      var rect = this.canvas.createPolygon({
          points: [
            0,
            bounds.height() / 2,
            bounds.width() / 2,
            0,
            bounds.width(),
            bounds.height() / 2,
            bounds.width() / 2,
            bounds.height()
          ],
          stroke: "black",
          fill: "white",
          strokeWidth: 2,
          draggable: true
        });
      group.add(rect);
      return group;
    };
  };
  return GatewayRenderer;


});
define('bpmn/editor/LabelRenderer',['require','exports','module'],function (require, exports, module) {
  

var Label = function (renderer) {
    this.renderCentered = function (bounds, group, labelText) {
      var text = this.createLabelText(labelText);
      text.setY(bounds.height() / 2 - text.getFontSize());
      text.setWidth(bounds.width());
      group.add(text);
      return group;
    };
    this.createLabelText = function (text) {
      return renderer.canvas.createText({
        text: text,
        fontSize: renderer.skin()["label_font_size"],
        fontFamily: renderer.skin()["label_font_family"],
        fill: renderer.skin()["label_fill"],
        align: "center"
      });
    };
  };
  return Label;


});
define('bpmn/editor/Renderer',['require', 'exports', 'module', 'dojo/_base/declare', 'dojo/_base/array', '../Activity', '../Gateway', '../Event', '../SequenceFlow', '../util/diagram/Canvas', './ActivityRenderer', './EventRenderer', './GatewayRenderer', './LabelRenderer'], function (require, exports, module, declare, array, Activity, Gateway, Event, SequenceFlow, Canvas, ActivityRenderer, EventRenderer, GatewayRenderer, LabelRenderer) {
  

var Renderer = {
      skins: {
        "default": {
          "event_stroke": "black",
          "activity_stroke": "black",
          "activity_fill": "white",
          "activity_corner_radius": 10,
          "label_font_family": "Arial",
          "label_font_size": 12,
          "label_fill": "black"
        }
      },
      constructor: function (definitions, options) {
        this.definitions = definitions;
        this.skinName = "default";
        this.bindDelegates();
        this.evaluateOptionsAndDefaults(options);
        this.canvas = new Canvas(this.options);
      },
      bindDelegates: function () {
        this.activity = new ActivityRenderer(this);
        this.renderEvent = new EventRenderer().render;
        this.renderGateway = new GatewayRenderer().render;
        this.label = new LabelRenderer(this);
      },
      evaluateOptionsAndDefaults: function (options) {
        this.options = options;
        this.skinName = options.skin ? options.skin : "default";
        this.options.scale = options.scale ? options.scale : 1;
      },
      render: function () {
        this.renderElements();
        this.canvas.shapeLayer.draw();
        this.canvas.connectionsLayer.draw();
        this.canvas.labelLayer.draw();
      },
      renderElements: function () {
        if (this.definitions.process().length > 1) {
          throw new Error("Only single process models are supported");
        }
        array.forEach(this.definitions.process(), function (process) {
          array.forEach(process.flowElements(), function (flowElement) {
            this.renderElement(flowElement);
          }, this);
        }, this);
      },
      renderElement: function (element) {
        var group = this.canvas.createGroup({ draggable: true });
        if (element instanceof SequenceFlow) {
          this.renderConnection(element, group);
          this.canvas.connectionsLayer.add(group);
        } else if (element instanceof Activity) {
          this.label.renderCentered(element.getBounds(), this.activity.render(element, group), element.name());
          this.canvas.shapeLayer.add(group);
          this.setGroupBounds(group, element.getBounds());
        } else if (element instanceof Event) {
          this.renderEvent(element, group);
          this.canvas.shapeLayer.add(group);
          this.setGroupBounds(group, this.eventBounds(element));
        } else if (element instanceof Gateway) {
          this.renderGateway(element, group);
          this.canvas.shapeLayer.add(group);
          this.setGroupBounds(group, element.getBounds());
        } else {
          console.log("unable to render flowElement", element);
        }
        this.canvas.expandCanvasIfNeeded(group);
      },
      eventBounds: function (eventElement) {
        var bounds = eventElement.getBounds();
        return {
          x: function () {
            return bounds.x() + bounds.width() / 2;
          },
          y: function () {
            return bounds.y() + bounds.height() / 2;
          },
          width: function () {
            return bounds.width();
          },
          height: function () {
            return bounds.height();
          }
        };
      },
      setGroupBounds: function (group, bounds) {
        group.setX(bounds.x());
        group.setY(bounds.y());
        group.setWidth(bounds.width());
        group.setHeight(bounds.height());
      },
      renderConnection: function (connection, group) {
        var joinedPoints = [];
        array.forEach(connection.getWaypoints(), function (point) {
          joinedPoints.push(point.x);
          joinedPoints.push(point.y);
        });
        var arrow = this.canvas.createArrowLine(joinedPoints, {
            stroke: "black",
            strokeWidth: 2,
            lineCap: "round",
            lineJoin: "round"
          });
        group.add(arrow);
        return group;
      },
      skin: function () {
        return this.skins[this.skinName];
      }
    };
  return declare("bpmn.Renderer", null, Renderer);


});
define('bpmn/Bpmn',['require', 'exports', 'module', 'dojo/_base/declare', './Definitions', './execution/Instance', './util/Serializer', './editor/Renderer'], function (require, exports, module, declare, Definitions, Instance, Serializer, Renderer) {
  

var bpmn = {
      constructor: function () {
        this.renderer = Renderer;
        this.serializer = new Serializer();
      }
    };
  return declare("bpmn.Bpmn", null, bpmn);


});
    return require('bpmn/Bpmn');
  };
if (__isAMD) {
  return define(['sax', 'kinetic', 'dojo/_base/declare', 'dojo/_base/lang', 'dojo/_base/array', 'dojo/Deferred', 'dojo/topic'], bundleFactory);
} else {
    if (__isNode) {
        return module.exports = bundleFactory(require('sax'), require('kinetic'), require('dojo/_base/declare'), require('dojo/_base/lang'), require('dojo/_base/array'), require('dojo/Deferred'), require('dojo/topic'));
    } else {
        return bundleFactory((typeof sax !== 'undefined') ? sax : void 0, (typeof Kinetic !== 'undefined') ? Kinetic : void 0, (typeof declare !== 'undefined') ? declare : void 0, (typeof l !== 'undefined') ? l : void 0, (typeof array !== 'undefined') ? array : void 0, (typeof Deferred !== 'undefined') ? Deferred : void 0, (typeof topic !== 'undefined') ? topic : void 0);
    }
}
}).call(this, (typeof exports === 'object' ? global : window),
              (typeof exports === 'object' ? global : window))