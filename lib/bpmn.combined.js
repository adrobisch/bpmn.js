// Generated by uRequire v0.6.15 - template: 'combined' 
// Combined template optimized with RequireJS/r.js v2.1.13 & almond.
(function (global, window){
  
var __isAMD = !!(typeof define === 'function' && define.amd),
    __isNode = (typeof exports === 'object'),
    __isWeb = !__isNode;

  var __nodeRequire = (__isNode ? require :
      function(dep){
        throw new Error("uRequire detected missing dependency: '" + dep + "' - in a non-nodejs runtime. All it's binding variables were 'undefined'.")
      });
var bundleFactory = function(sax, Kinetic, $, _) {/**
 * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                name = baseParts.concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("almond", function(){});

define('bpmn/util/JSClass',['require','exports','module'],function (require, exports, module) {
  

var JS = typeof this.JS === "undefined" ? {} : this.JS;
(function (factory) {
  var $ = typeof this.global === "object" ? this.global : this, E = typeof exports === "object";
  if (E) {
    exports.JS = exports;
    JS = exports;
  } else {
    $.JS = JS;
  }
  factory($, JS);
}(function (global, exports) {
  "use strict";
  var JS = { ENV: global };
  JS.END_WITHOUT_DOT = /([^\.])$/;
  JS.array = function (enumerable) {
    var array = [], i = enumerable.length;
    while (i--)
      array[i] = enumerable[i];
    return array;
  };
  JS.bind = function (method, object) {
    return function () {
      return method.apply(object, arguments);
    };
  };
  JS.Date = JS.ENV.Date;
  JS.extend = function (destination, source, overwrite) {
    if (!destination || !source)
      return destination;
    for (var field in source) {
      if (destination[field] === source[field])
        continue;
      if (overwrite === false && destination.hasOwnProperty(field))
        continue;
      destination[field] = source[field];
    }
    return destination;
  };
  JS.indexOf = function (list, item) {
    if (list.indexOf)
      return list.indexOf(item);
    var i = list.length;
    while (i--) {
      if (list[i] === item)
        return i;
    }
    return -1;
  };
  JS.isType = function (object, type) {
    if (typeof type === "string")
      return typeof object === type;
    if (object === null || object === undefined)
      return false;
    return typeof type === "function" && object instanceof type || object.isA && object.isA(type) || object.constructor === type;
  };
  JS.makeBridge = function (parent) {
    var bridge = function () {
    };
    bridge.prototype = parent.prototype;
    return new bridge();
  };
  JS.makeClass = function (parent) {
    parent = parent || Object;
    var constructor = function () {
      return this.initialize ? this.initialize.apply(this, arguments) || this : this;
    };
    constructor.prototype = JS.makeBridge(parent);
    constructor.superclass = parent;
    constructor.subclasses = [];
    if (parent.subclasses)
      parent.subclasses.push(constructor);
    return constructor;
  };
  JS.match = function (category, object) {
    if (object === undefined)
      return false;
    return typeof category.test === "function" ? category.test(object) : category.match(object);
  };
  JS.Method = JS.makeClass();
  JS.extend(JS.Method.prototype, {
    initialize: function (module, name, callable) {
      this.module = module;
      this.name = name;
      this.callable = callable;
      this._words = {};
      if (typeof callable !== "function")
        return;
      this.arity = callable.length;
      var matches = callable.toString().match(/\b[a-z\_\$][a-z0-9\_\$]*\b/gi), i = matches.length;
      while (i--)
        this._words[matches[i]] = true;
    },
    setName: function (name) {
      this.callable.displayName = this.displayName = name;
    },
    contains: function (word) {
      return this._words.hasOwnProperty(word);
    },
    call: function () {
      return this.callable.call.apply(this.callable, arguments);
    },
    apply: function (receiver, args) {
      return this.callable.apply(receiver, args);
    },
    compile: function (environment) {
      var method = this, trace = method.module.__trace__ || environment.__trace__, callable = method.callable, words = method._words, allWords = JS.Method._keywords, i = allWords.length, keywords = [], keyword;
      while (i--) {
        keyword = allWords[i];
        if (words[keyword.name])
          keywords.push(keyword);
      }
      if (keywords.length === 0 && !trace)
        return callable;
      var compiled = function () {
        var N = keywords.length, j = N, previous = {}, keyword, existing, kwd;
        while (j--) {
          keyword = keywords[j];
          existing = this[keyword.name];
          if (existing && !existing.__kwd__)
            continue;
          previous[keyword.name] = {
            _value: existing,
            _own: this.hasOwnProperty(keyword.name)
          };
          kwd = keyword.filter(method, environment, this, arguments);
          if (kwd)
            kwd.__kwd__ = true;
          this[keyword.name] = kwd;
        }
        var returnValue = callable.apply(this, arguments), j = N;
        while (j--) {
          keyword = keywords[j];
          if (!previous[keyword.name])
            continue;
          if (previous[keyword.name]._own)
            this[keyword.name] = previous[keyword.name]._value;
          else
            delete this[keyword.name];
        }
        return returnValue;
      };
      return compiled;
    },
    toString: function () {
      var name = this.displayName || this.module.toString() + "#" + this.name;
      return "#<Method:" + name + ">";
    }
  });
  JS.Method.create = function (module, name, callable) {
    if (callable && callable.__inc__ && callable.__fns__)
      return callable;
    var method = typeof callable !== "function" ? callable : new this(module, name, callable);
    this.notify(method);
    return method;
  };
  JS.Method.compile = function (method, environment) {
    return method instanceof this ? method.compile(environment) : method;
  };
  JS.Method.__listeners__ = [];
  JS.Method.added = function (block, context) {
    this.__listeners__.push([
      block,
      context
    ]);
  };
  JS.Method.notify = function (method) {
    var listeners = this.__listeners__, i = listeners.length, listener;
    while (i--) {
      listener = listeners[i];
      listener[0].call(listener[1], method);
    }
  };
  JS.Method._keywords = [];
  JS.Method.keyword = function (name, filter) {
    this._keywords.push({
      name: name,
      filter: filter
    });
  };
  JS.Method.trace = function (classes) {
    var i = classes.length;
    while (i--) {
      classes[i].__trace__ = true;
      classes[i].resolve();
    }
  };
  JS.Method.untrace = function (classes) {
    var i = classes.length;
    while (i--) {
      classes[i].__trace__ = false;
      classes[i].resolve();
    }
  };
  JS.Module = JS.makeClass();
  JS.Module.__queue__ = [];
  JS.extend(JS.Module.prototype, {
    initialize: function (name, methods, options) {
      if (typeof name !== "string") {
        options = arguments[1];
        methods = arguments[0];
        name = undefined;
      }
      options = options || {};
      this.__inc__ = [];
      this.__dep__ = [];
      this.__fns__ = {};
      this.__tgt__ = options._target;
      this.__anc__ = null;
      this.__mct__ = {};
      this.setName(name);
      this.include(methods, { _resolve: false });
      if (JS.Module.__queue__)
        JS.Module.__queue__.push(this);
    },
    setName: function (name) {
      this.displayName = name || "";
      for (var field in this.__fns__)
        this.__name__(field);
      if (name && this.__meta__)
        this.__meta__.setName(name + ".");
    },
    __name__: function (name) {
      if (!this.displayName)
        return;
      var object = this.__fns__[name];
      if (!object)
        return;
      name = this.displayName.replace(JS.END_WITHOUT_DOT, "$1#") + name;
      if (typeof object.setName === "function")
        return object.setName(name);
      if (typeof object === "function")
        object.displayName = name;
    },
    define: function (name, callable, options) {
      var method = JS.Method.create(this, name, callable), resolve = (options || {})._resolve;
      this.__fns__[name] = method;
      this.__name__(name);
      if (resolve !== false)
        this.resolve();
    },
    include: function (module, options) {
      if (!module)
        return this;
      var options = options || {}, resolve = options._resolve !== false, extend = module.extend, include = module.include, extended, field, value, mixins, i, n;
      if (module.__fns__ && module.__inc__) {
        this.__inc__.push(module);
        if ((module.__dep__ || {}).push)
          module.__dep__.push(this);
        if (extended = options._extended) {
          if (typeof module.extended === "function")
            module.extended(extended);
        } else {
          if (typeof module.included === "function")
            module.included(this);
        }
      } else {
        if (this.shouldIgnore("extend", extend)) {
          mixins = [].concat(extend);
          for (i = 0, n = mixins.length; i < n; i++)
            this.extend(mixins[i]);
        }
        if (this.shouldIgnore("include", include)) {
          mixins = [].concat(include);
          for (i = 0, n = mixins.length; i < n; i++)
            this.include(mixins[i], { _resolve: false });
        }
        for (field in module) {
          if (!module.hasOwnProperty(field))
            continue;
          value = module[field];
          if (this.shouldIgnore(field, value))
            continue;
          this.define(field, value, { _resolve: false });
        }
        if (module.hasOwnProperty("toString"))
          this.define("toString", module.toString, { _resolve: false });
      }
      if (resolve)
        this.resolve();
      return this;
    },
    alias: function (aliases) {
      for (var method in aliases) {
        if (!aliases.hasOwnProperty(method))
          continue;
        this.define(method, this.instanceMethod(aliases[method]), { _resolve: false });
      }
      this.resolve();
    },
    resolve: function (host) {
      var host = host || this, target = host.__tgt__, inc = this.__inc__, fns = this.__fns__, i, n, key, compiled;
      if (host === this) {
        this.__anc__ = null;
        this.__mct__ = {};
        i = this.__dep__.length;
        while (i--)
          this.__dep__[i].resolve();
      }
      if (!target)
        return;
      for (i = 0, n = inc.length; i < n; i++)
        inc[i].resolve(host);
      for (key in fns) {
        compiled = JS.Method.compile(fns[key], host);
        if (target[key] !== compiled)
          target[key] = compiled;
      }
      if (fns.hasOwnProperty("toString"))
        target.toString = JS.Method.compile(fns.toString, host);
    },
    shouldIgnore: function (field, value) {
      return (field === "extend" || field === "include") && (typeof value !== "function" || value.__fns__ && value.__inc__);
    },
    ancestors: function (list) {
      var cachable = !list, list = list || [], inc = this.__inc__;
      if (cachable && this.__anc__)
        return this.__anc__.slice();
      for (var i = 0, n = inc.length; i < n; i++)
        inc[i].ancestors(list);
      if (JS.indexOf(list, this) < 0)
        list.push(this);
      if (cachable)
        this.__anc__ = list.slice();
      return list;
    },
    lookup: function (name) {
      var cached = this.__mct__[name];
      if (cached && cached.slice)
        return cached.slice();
      var ancestors = this.ancestors(), methods = [], fns;
      for (var i = 0, n = ancestors.length; i < n; i++) {
        fns = ancestors[i].__fns__;
        if (fns.hasOwnProperty(name))
          methods.push(fns[name]);
      }
      this.__mct__[name] = methods.slice();
      return methods;
    },
    includes: function (module) {
      if (module === this)
        return true;
      var inc = this.__inc__;
      for (var i = 0, n = inc.length; i < n; i++) {
        if (inc[i].includes(module))
          return true;
      }
      return false;
    },
    instanceMethod: function (name) {
      return this.lookup(name).pop();
    },
    instanceMethods: function (recursive, list) {
      var methods = list || [], fns = this.__fns__, field;
      for (field in fns) {
        if (!JS.isType(this.__fns__[field], JS.Method))
          continue;
        if (JS.indexOf(methods, field) >= 0)
          continue;
        methods.push(field);
      }
      if (recursive !== false) {
        var ancestors = this.ancestors(), i = ancestors.length;
        while (i--)
          ancestors[i].instanceMethods(false, methods);
      }
      return methods;
    },
    match: function (object) {
      return object && object.isA && object.isA(this);
    },
    toString: function () {
      return this.displayName;
    }
  });
  JS.Kernel = new JS.Module("Kernel", {
    __eigen__: function () {
      if (this.__meta__)
        return this.__meta__;
      var name = this.toString() + ".";
      this.__meta__ = new JS.Module(name, null, { _target: this });
      return this.__meta__.include(this.klass, { _resolve: false });
    },
    equals: function (other) {
      return this === other;
    },
    extend: function (module, options) {
      var resolve = (options || {})._resolve;
      this.__eigen__().include(module, {
        _extended: this,
        _resolve: resolve
      });
      return this;
    },
    hash: function () {
      return JS.Kernel.hashFor(this);
    },
    isA: function (module) {
      return typeof module === "function" && this instanceof module || this.__eigen__().includes(module);
    },
    method: function (name) {
      var cache = this.__mct__ = this.__mct__ || {}, value = cache[name], field = this[name];
      if (typeof field !== "function")
        return field;
      if (value && field === value._value)
        return value._bound;
      var bound = JS.bind(field, this);
      cache[name] = {
        _value: field,
        _bound: bound
      };
      return bound;
    },
    methods: function () {
      return this.__eigen__().instanceMethods();
    },
    tap: function (block, context) {
      block.call(context, this);
      return this;
    },
    toString: function () {
      if (this.displayName)
        return this.displayName;
      var name = this.klass.displayName || this.klass.toString();
      return "#<" + name + ":" + this.hash() + ">";
    }
  });
  (function () {
    var id = 1;
    JS.Kernel.hashFor = function (object) {
      if (object.__hash__ !== undefined)
        return object.__hash__;
      object.__hash__ = (new JS.Date().getTime() + id).toString(16);
      id += 1;
      return object.__hash__;
    };
  }());
  JS.Class = JS.makeClass(JS.Module);
  JS.extend(JS.Class.prototype, {
    initialize: function (name, parent, methods, options) {
      if (typeof name !== "string") {
        options = arguments[2];
        methods = arguments[1];
        parent = arguments[0];
        name = undefined;
      }
      if (typeof parent !== "function") {
        options = methods;
        methods = parent;
        parent = Object;
      }
      JS.Module.prototype.initialize.call(this, name);
      options = options || {};
      var klass = JS.makeClass(parent);
      JS.extend(klass, this);
      klass.prototype.constructor = klass.prototype.klass = klass;
      klass.__eigen__().include(parent.__meta__, { _resolve: options._resolve });
      klass.setName(name);
      klass.__tgt__ = klass.prototype;
      var parentModule = parent === Object ? {} : parent.__fns__ ? parent : new JS.Module(parent.prototype, { _resolve: false });
      klass.include(JS.Kernel, { _resolve: false }).include(parentModule, { _resolve: false }).include(methods, { _resolve: false });
      if (options._resolve !== false)
        klass.resolve();
      if (typeof parent.inherited === "function")
        parent.inherited(klass);
      return klass;
    }
  });
  (function () {
    var methodsFromPrototype = function (klass) {
      var methods = {}, proto = klass.prototype;
      for (var field in proto) {
        if (!proto.hasOwnProperty(field))
          continue;
        methods[field] = JS.Method.create(klass, field, proto[field]);
      }
      return methods;
    };
    var classify = function (name, parentName) {
      var klass = JS[name], parent = JS[parentName];
      klass.__inc__ = [];
      klass.__dep__ = [];
      klass.__fns__ = methodsFromPrototype(klass);
      klass.__tgt__ = klass.prototype;
      klass.prototype.constructor = klass.prototype.klass = klass;
      JS.extend(klass, JS.Class.prototype);
      klass.include(parent || JS.Kernel);
      klass.setName(name);
      klass.constructor = klass.klass = JS.Class;
    };
    classify("Method");
    classify("Module");
    classify("Class", "Module");
    var eigen = JS.Kernel.instanceMethod("__eigen__");
    eigen.call(JS.Method).resolve();
    eigen.call(JS.Module).resolve();
    eigen.call(JS.Class).include(JS.Module.__meta__);
  }());
  JS.NotImplementedError = new JS.Class("NotImplementedError", Error);
  JS.Method.keyword("callSuper", function (method, env, receiver, args) {
    var methods = env.lookup(method.name), stackIndex = methods.length - 1, params = JS.array(args);
    if (stackIndex === 0)
      return undefined;
    var _super = function () {
      var i = arguments.length;
      while (i--)
        params[i] = arguments[i];
      stackIndex -= 1;
      if (stackIndex === 0)
        delete receiver.callSuper;
      var returnValue = methods[stackIndex].apply(receiver, params);
      receiver.callSuper = _super;
      stackIndex += 1;
      return returnValue;
    };
    return _super;
  });
  JS.Method.keyword("blockGiven", function (method, env, receiver, args) {
    var block = Array.prototype.slice.call(args, method.arity), hasBlock = typeof block[0] === "function";
    return function () {
      return hasBlock;
    };
  });
  JS.Method.keyword("yieldWith", function (method, env, receiver, args) {
    var block = Array.prototype.slice.call(args, method.arity);
    return function () {
      if (typeof block[0] !== "function")
        return;
      return block[0].apply(block[1] || null, arguments);
    };
  });
  JS.Interface = new JS.Class("Interface", {
    initialize: function (methods) {
      this.test = function (object, returnName) {
        var n = methods.length;
        while (n--) {
          if (typeof object[methods[n]] !== "function")
            return returnName ? methods[n] : false;
        }
        return true;
      };
    },
    extend: {
      ensure: function () {
        var args = JS.array(arguments), object = args.shift(), face, result;
        while (face = args.shift()) {
          result = face.test(object, true);
          if (result !== true)
            throw new Error("object does not implement " + result + "()");
        }
      }
    }
  });
  JS.Singleton = new JS.Class("Singleton", {
    initialize: function (name, parent, methods) {
      return new new JS.Class(name, parent, methods)();
    }
  });
  JS.extend(exports, JS);
  if (global.JS)
    JS.extend(global.JS, JS);
}));

return module.exports;

});
define('bpmn/util/Index',['require', 'exports', 'module', './JSClass'], function (require, exports, module, jsclass) {
  

var index = {
      initialize: function () {
        this._ = {};
      },
      add: function (key, value) {
        this._[key] = value;
      },
      addArray: function (key, value) {
        if (!this._[key]) {
          this._[key] = [];
        }
        this._[key].push(value);
      },
      addMap: function (key, property, value) {
        if (!this._[key]) {
          this._[key] = {};
        }
        this._[key][property] = value;
      },
      item: function (key) {
        return this._[key];
      }
    };
  return new jsclass.Class(index);


});
define('bpmn/Clazz',['require', 'exports', 'module', './util/JSClass'], function (require, exports, module, jsclass) {
  

var clazz = {
      initialize: function () {
        this.text = null;
        this.reference = {};
        this.attribute = {};
      },
      addReference: function (ref) {
        this.reference[ref.name] = ref;
        var name = this.__internalFieldName(ref.name);
        if (ref.containment === true) {
          this[name] = [];
        } else {
          this[name] = null;
        }
        this[ref.name] = function (newValue) {
          return this.accessor(ref.name, newValue);
        };
      },
      addAttribute: function (attr) {
        this.attribute[attr.name] = attr;
        this[attr.name] = function (newValue) {
          return this.accessor(attr.name, newValue);
        };
      },
      accessor: function (field, newValue) {
        var name = this.__internalFieldName(field);
        if (newValue != null && newValue != undefined) {
          this[name] = newValue;
        }
        return this[name];
      },
      __internalFieldName: function (field) {
        return "_" + field;
      },
      init: function () {
      },
      setText: function (text) {
        this.text = text;
      }
    };
  return new jsclass.Class(clazz);


});
define('bpmn/BaseElement',['require', 'exports', 'module', './util/JSClass', './Clazz'], function (require, exports, module, jsclass, Clazz) {
  

var baseElement = {
      tag: "baseElement",
      initialize: function () {
        this.callSuper();
        this.addReference({
          name: "documentation",
          type: function Documentation() {
          }
        });
        this.addAttribute({
          name: "id",
          type: String
        });
        this.addAttribute({
          name: "name",
          type: String
        });
        var uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
            return v.toString(16);
          });
        this.id(uuid);
      },
      init: function () {
        var id = this.id();
        this._definitions.index.add(id, this);
        this._definitions.index.addMap(this.declaredClass, id, this);
      }
    };
  return new jsclass.Class(Clazz, baseElement);


});
define('bpmn/CallableElement',['require', 'exports', 'module', './util/JSClass', './BaseElement'], function (require, exports, module, jsclass, BaseElement) {
  

var callableElement = {
      initialize: function () {
        this.callSuper();
        this.addAttribute({
          name: "name",
          type: String
        });
      },
      init: function () {
        this.callSuper();
      }
    };
  return new jsclass.Class(BaseElement, callableElement);


});
define('bpmn/Package',['require', 'exports', 'module', './util/JSClass'], function (require, exports, module, jsclass) {
  

var packageDef = {
      tagMap: {},
      initialize: function () {
      },
      registerClass: function (newClass) {
        var tag = newClass.prototype.tag;
        if (tag) {
          this.tagMap[tag.toLowerCase()] = newClass;
        }
        return newClass;
      }
    };
  var Package = new jsclass.Class(packageDef);
  return new Package();


});
define('bpmn/FlowElement',['require', 'exports', 'module', './util/JSClass', './BaseElement', './Package'], function (require, exports, module, jsclass, BaseElement, Package) {
  

var flowElement = {
      tag: "flowElement",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      },
      getDiagramElement: function () {
        return this._definitions.index.item(this.id() + ":di");
      },
      getBounds: function () {
        return this.getDiagramElement().bounds();
      },
      getWaypoints: function () {
        return this.getDiagramElement().waypoints();
      }
    };
  var FlowElementClass = new jsclass.Class(BaseElement, flowElement);
  Package.registerClass(FlowElementClass);
  return FlowElementClass;


});
define('bpmn/FlowElementsContainer',['require', 'exports', 'module', './util/JSClass', './BaseElement', './FlowElement'], function (require, exports, module, jsclass, BaseElement, FlowElement) {
  

var flowElementsContainer = {
      initialize: function () {
        this.callSuper();
        this.addReference({
          name: "flowElements",
          containment: true,
          type: FlowElement
        });
      },
      init: function () {
        this.callSuper();
      }
    };
  return new jsclass.Module(flowElementsContainer);


});
define('bpmn/Process',['require', 'exports', 'module', './util/JSClass', './CallableElement', './FlowElementsContainer', './Package'], function (require, exports, module, jsclass, CallableElement, FlowElementsContainer, Package) {
  

var process = {
      include: [FlowElementsContainer],
      tag: "process",
      initialize: function () {
        this.callSuper();
        this.addAttribute({
          name: "isExecutable",
          type: "boolean"
        });
        this.addAttribute({
          name: "name",
          type: String
        });
      }
    };
  var processClass = new jsclass.Class(CallableElement, process);
  return Package.registerClass(processClass);


});
define('bpmn/Collaboration',['require', 'exports', 'module', './util/JSClass', './Package'], function (require, exports, module, jsclass, Package) {
  

var collaboration = {
      tag: "collaboration",
      initialize: function () {
      }
    };
  var CollaborationClass = new jsclass.Class(collaboration);
  Package.registerClass(CollaborationClass);
  return CollaborationClass;


});
define('bpmn/di/DiagramElement',['require', 'exports', 'module', '../util/JSClass', '../Clazz', '../Package'], function (require, exports, module, jsclass, Clazz, Package) {
  

var DiagramElement = {
      tag: "diagramElement",
      initialize: function () {
        this.callSuper();
        this.addAttribute({
          name: "id",
          type: String
        });
        this.addAttribute({
          name: "bpmnElement",
          type: String
        });
      },
      init: function () {
        this._definitions.index.add(this.bpmnElement() + ":di", this);
      }
    };
  var DiagramElementClass = new jsclass.Class(Clazz, DiagramElement);
  Package.registerClass(DiagramElementClass);
  return DiagramElementClass;


});
define('bpmn/di/Bounds',['require', 'exports', 'module', '../util/JSClass', '../Clazz', '../Package'], function (require, exports, module, jsclass, Clazz, Package) {
  

var Bounds = {
      tag: "Bounds",
      initialize: function () {
        this.callSuper();
        this.addAttribute({
          name: "x",
          type: "float"
        });
        this.addAttribute({
          name: "y",
          type: "float"
        });
        this.addAttribute({
          name: "width",
          type: "float"
        });
        this.addAttribute({
          name: "height",
          type: "float"
        });
      },
      init: function () {
        this.callSuper();
      }
    };
  var BoundsClass = new jsclass.Class(Clazz, Bounds);
  Package.registerClass(BoundsClass);
  return BoundsClass;


});
define('bpmn/di/BPMNShape',['require', 'exports', 'module', '../util/JSClass', './DiagramElement', './Bounds', '../Package'], function (require, exports, module, jsclass, DiagramElement, Bounds, Package) {
  

var BPMNShape = {
      tag: "BPMNShape",
      initialize: function () {
        this.callSuper();
        this.addReference({
          name: "bounds",
          type: Bounds
        });
      },
      init: function () {
        this.callSuper();
      }
    };
  var BPMNShapeClass = new jsclass.Class(DiagramElement, BPMNShape);
  Package.registerClass(BPMNShapeClass);
  return BPMNShapeClass;


});
define('bpmn/di/Waypoint',['require', 'exports', 'module', '../util/JSClass', '../Clazz', '../Package'], function (require, exports, module, jsclass, Clazz, Package) {
  

var Waypoint = {
      tag: "waypoint",
      initialize: function () {
        this.callSuper();
        this.addAttribute({
          name: "x",
          type: "float"
        });
        this.addAttribute({
          name: "y",
          type: "float"
        });
      },
      init: function () {
        this.callSuper();
      },
      __internalFieldName: function (field) {
        return field;
      }
    };
  var WaypointClass = new jsclass.Class(Clazz, Waypoint);
  Package.registerClass(WaypointClass);
  return WaypointClass;


});
define('bpmn/di/BPMNEdge',['require', 'exports', 'module', '../util/JSClass', './DiagramElement', './Waypoint', '../Package'], function (require, exports, module, jsclass, DiagramElement, Waypoint, Package) {
  

var BPMNEdge = {
      tag: "BPMNEdge",
      initialize: function () {
        this.callSuper();
        this.addReference({
          name: "waypoints",
          containment: true,
          type: Waypoint
        });
      },
      init: function () {
        this.callSuper();
      }
    };
  var BPMNEdgeClass = new jsclass.Class(DiagramElement, BPMNEdge);
  Package.registerClass(BPMNEdgeClass);
  return BPMNEdgeClass;


});
define('bpmn/di/BPMNPlane',['require', 'exports', 'module', '../util/JSClass', '../Clazz', '../Package', './BPMNShape', './BPMNEdge', './DiagramElement'], function (require, exports, module, jsclass, Clazz, Package, Shape, Edge, DiagramElement) {
  

var BPMNPlane = {
      tag: "BPMNPlane",
      initialize: function () {
        this.callSuper();
        this.addReference({
          name: "diagramElements",
          containment: true,
          type: DiagramElement
        });
      },
      init: function () {
        this.callSuper();
      }
    };
  var BPMNPlaneClass = new jsclass.Class(Clazz, BPMNPlane);
  Package.registerClass(BPMNPlaneClass);
  return BPMNPlaneClass;


});
define('bpmn/di/BPMNDiagram',['require', 'exports', 'module', '../util/JSClass', '../Clazz', './BPMNPlane', '../Package'], function (require, exports, module, jsclass, Clazz, BPMNPlane, Package) {
  

var BPMNDiagram = {
      tag: "BPMNDiagram",
      initialize: function () {
        this.callSuper();
        this.addReference({
          name: "plane",
          type: BPMNPlane
        });
      }
    };
  var BPMNDiagramClass = new jsclass.Class(Clazz, BPMNDiagram);
  Package.registerClass(BPMNDiagramClass);
  return BPMNDiagramClass;


});
define('bpmn/FlowNode',['require', 'exports', 'module', './util/JSClass', './FlowElement', './Package'], function (require, exports, module, jsclass, FlowElement, Package) {
  

var flowNode = {
      tag: "flowNode",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      },
      incoming: function () {
        var incoming = this._definitions.index.item("target:" + this.id());
        return incoming ? incoming : [];
      },
      outgoing: function () {
        var outgoing = this._definitions.index.item("source:" + this.id());
        return outgoing ? outgoing : [];
      }
    };
  var FlowNodeClass = new jsclass.Class(FlowElement, flowNode);
  Package.registerClass(FlowNodeClass);
  return FlowNodeClass;


});
define('bpmn/Event',['require', 'exports', 'module', './util/JSClass', './FlowNode', './Package'], function (require, exports, module, jsclass, FlowNode, Package) {
  

var event = {
      tag: "event",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var EventClass = new jsclass.Class(FlowNode, event);
  Package.registerClass(EventClass);
  return EventClass;


});
define('bpmn/CatchEvent',['require', 'exports', 'module', './util/JSClass', './Event', './Package'], function (require, exports, module, jsclass, Event, Package) {
  

var catchEvent = {
      tag: "catchEvent",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var CatchEventClass = new jsclass.Class(Event, catchEvent);
  Package.registerClass(CatchEventClass);
  return CatchEventClass;


});
define('bpmn/StartEvent',['require', 'exports', 'module', './util/JSClass', './CatchEvent', './Package'], function (require, exports, module, jsclass, CatchEvent, Package) {
  

var startEvent = {
      tag: "startEvent",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var StartEventClass = new jsclass.Class(CatchEvent, startEvent);
  Package.registerClass(StartEventClass);
  return StartEventClass;


});
define('bpmn/ThrowEvent',['require', 'exports', 'module', './util/JSClass', './Event', './Package'], function (require, exports, module, jsclass, Event, Package) {
  

var throwEvent = {
      tag: "throwEvent",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var ThrowEventClass = new jsclass.Class(Event, throwEvent);
  Package.registerClass(ThrowEventClass);
  return ThrowEventClass;


});
define('bpmn/EndEvent',['require', 'exports', 'module', './util/JSClass', './ThrowEvent', './Package'], function (require, exports, module, jsclass, ThrowEvent, Package) {
  

var endEvent = {
      tag: "endEvent",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var EndEventClass = new jsclass.Class(ThrowEvent, endEvent);
  Package.registerClass(EndEventClass);
  return EndEventClass;


});
define('bpmn/BoundaryEvent',['require', 'exports', 'module', './util/JSClass', './CatchEvent', './Package'], function (require, exports, module, jsclass, CatchEvent, Package) {
  

var boundaryEvent = {
      tag: "boundaryEvent",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var BoundaryEventClass = new jsclass.Class(CatchEvent, boundaryEvent);
  Package.registerClass(BoundaryEventClass);
  return BoundaryEventClass;


});
define('bpmn/Activity',['require', 'exports', 'module', './util/JSClass', './FlowNode', './Package'], function (require, exports, module, jsclass, FlowNode, Package) {
  

var activity = {
      tag: "activity",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var ActivityClass = new jsclass.Class(FlowNode, activity);
  Package.registerClass(ActivityClass);
  return ActivityClass;


});
define('bpmn/Task',['require', 'exports', 'module', './util/JSClass', './Activity', './Package'], function (require, exports, module, jsclass, Activity, Package) {
  

var task = {
      tag: "task",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var TaskClass = new jsclass.Class(Activity, task);
  Package.registerClass(TaskClass);
  return TaskClass;


});
define('bpmn/UserTask',['require', 'exports', 'module', './util/JSClass', './Task', './Package'], function (require, exports, module, jsclass, Task, Package) {
  

var userTask = {
      tag: "userTask",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var UserTaskClass = new jsclass.Class(Task, userTask);
  Package.registerClass(UserTaskClass);
  return UserTaskClass;


});
define('bpmn/ServiceTask',['require', 'exports', 'module', './util/JSClass', './Task', './Package'], function (require, exports, module, jsclass, Task, Package) {
  

var serviceTask = {
      tag: "serviceTask",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var ServiceTaskClass = new jsclass.Class(Task, serviceTask);
  Package.registerClass(ServiceTaskClass);
  return ServiceTaskClass;


});
define('bpmn/BusinessRuleTask',['require', 'exports', 'module', './util/JSClass', './Task', './Package'], function (require, exports, module, jsclass, Task, Package) {
  

var businessRuleTask = {
      tag: "businessRuleTask",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var BusinessRuleTaskClass = new jsclass.Class(Task, businessRuleTask);
  Package.registerClass(BusinessRuleTaskClass);
  return BusinessRuleTaskClass;


});
define('bpmn/ReceiveTask',['require', 'exports', 'module', './util/JSClass', './Task', './Package'], function (require, exports, module, jsclass, Task, Package) {
  

var receiveTask = {
      tag: "receiveTask",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var ReceiveTaskClass = new jsclass.Class(Task, receiveTask);
  Package.registerClass(ReceiveTaskClass);
  return ReceiveTaskClass;


});
define('bpmn/SubProcess',['require', 'exports', 'module', './util/JSClass', './Activity', './FlowElementsContainer', './Package'], function (require, exports, module, jsclass, Activity, FlowElementsContainer, Package) {
  

var subProcess = {
      include: [FlowElementsContainer],
      tag: "subProcess",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var SubProcessClass = new jsclass.Class(Activity, subProcess);
  Package.registerClass(SubProcessClass);
  return SubProcessClass;


});
define('bpmn/Gateway',['require', 'exports', 'module', './util/JSClass', './FlowNode', './Package'], function (require, exports, module, jsclass, FlowNode, Package) {
  

var gateway = {
      tag: "gateway",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var GatewayClass = new jsclass.Class(FlowNode, gateway);
  Package.registerClass(GatewayClass);
  return GatewayClass;


});
define('bpmn/ExclusiveGateway',['require', 'exports', 'module', './util/JSClass', './Gateway', './Package'], function (require, exports, module, jsclass, Gateway, Package) {
  

var exclusiveGateway = {
      tag: "exclusiveGateway",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var ExclusiveGateway = new jsclass.Class(Gateway, exclusiveGateway);
  Package.registerClass(ExclusiveGateway);
  return ExclusiveGateway;


});
define('bpmn/ParallelGateway',['require', 'exports', 'module', './util/JSClass', './Gateway', './Package'], function (require, exports, module, jsclass, Gateway, Package) {
  

var parallelGateway = {
      tag: "parallelGateway",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var ParallelGatewayClass = new jsclass.Class(Gateway, parallelGateway);
  Package.registerClass(ParallelGatewayClass);
  return ParallelGatewayClass;


});
define('bpmn/ConditionExpression',['require', 'exports', 'module', './util/JSClass', './BaseElement', './Package'], function (require, exports, module, jsclass, BaseElement, Package) {
  

var conditionExpression = {
      tag: "conditionExpression",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var ConditionExpressionClass = new jsclass.Class(BaseElement, conditionExpression);
  Package.registerClass(ConditionExpressionClass);
  return ConditionExpressionClass;


});
define('bpmn/SequenceFlow',['require', 'exports', 'module', './util/JSClass', './FlowElement', './ConditionExpression', './Package'], function (require, exports, module, jsclass, FlowElement, ConditionExpression, Package) {
  

var sequenceFlow = {
      tag: "sequenceFlow",
      initialize: function () {
        this.callSuper();
        this.addAttribute({
          name: "sourceRef",
          type: String
        });
        this.addAttribute({
          name: "targetRef",
          type: String
        });
        this.addReference({
          name: "conditionExpression",
          type: ConditionExpression
        });
      },
      getSourceRef: function () {
        return this._definitions.index.item(this._sourceRef);
      },
      getTargetRef: function () {
        return this._definitions.index.item(this._targetRef);
      },
      init: function () {
        this.callSuper();
        if (!this._definitions.index.addArray) {
          console.log("cant addArray" + this.id());
          console.log(this._definitions.index.tag);
        }
        this._definitions.index.addArray("target:" + this.targetRef(), this);
        this._definitions.index.addArray("source:" + this.sourceRef(), this);
      }
    };
  var SequenceFlowClass = new jsclass.Class(FlowElement, sequenceFlow);
  Package.registerClass(SequenceFlowClass);
  return SequenceFlowClass;


});
define('bpmn/Definitions',['require', 'exports', 'module', './util/JSClass', './util/Index', './BaseElement', './Process', './Collaboration', './di/BPMNDiagram', './StartEvent', './EndEvent', './BoundaryEvent', './UserTask', './ServiceTask', './BusinessRuleTask', './ReceiveTask', './SubProcess', './ExclusiveGateway', './ParallelGateway', './SequenceFlow'], function (require, exports, module, jsclass, Index, BaseElement, Process, Collaboration, BPMNDiagram) {
  

var definitions = {
      tag: "definitions",
      initialize: function () {
        this.callSuper();
        this.addReference({
          name: "collaboration",
          type: Collaboration
        });
        this.addReference({
          name: "process",
          containment: true,
          type: Process
        });
        this.addReference({
          name: "bpmnDiagram",
          type: BPMNDiagram
        });
        this.index = new Index();
      }
    };
  return new jsclass.Class(BaseElement, definitions);


});
define('bpmn/execution/TokenStore',['require', 'exports', 'module', '../util/JSClass'], function (require, exports, module, jsclass) {
  

var tokenStore = {
      constructor: function (tokenMap) {
        this.tokenMap = tokenMap ? tokenMap : {};
      },
      add: function (id, token) {
        if (!this.tokenMap[id]) {
          this.tokenMap[id] = [];
        }
        this.tokenMap[id].push(token);
      },
      drop: function (id, count) {
        if (this.tokenMap[id]) {
          for (var c = 0; c < count; c++) {
            this.tokenMap[id].pop();
          }
        }
      },
      query: function (id) {
        return this.tokenMap[id] ? this.tokenMap[id] : [];
      },
      count: function () {
        var result = 0;
        for (var key in this.tokenMap) {
          result += this.tokenMap[key].length;
        }
        return result;
      }
    };
  return new jsclass.Class(tokenStore);


});
define('lodash',[],function () {
  if (__isNode) {
  return __nodeRequire('lodash');
} else {
  return (typeof _ !== 'undefined') ? _ : __nodeRequire('lodash')
}
});
define('jquery',[],function () {
  if (__isNode) {
  return __nodeRequire('jquery');
} else {
  return (typeof $ !== 'undefined') ? $ : __nodeRequire('jquery')
}
});
define('bpmn/util/Topic',['require', 'exports', 'module', './JSClass'], function (require, exports, module, jsclass) {
  

var topic = {
      publish: function (eventPath, message) {
      }
    };
  return new jsclass.Class(topic);


});
define('bpmn/execution/Instance',['require', 'exports', 'module', './TokenStore', '../util/JSClass', 'lodash', 'jquery', '../util/Topic'], function (require, exports, module, TokenStore, jsclass, _, $, topic) {
  

var instance = {
      constructor: function (definitions, configuration, tokenMap, variables) {
        this.definitions = definitions;
        this.configuration = configuration;
        this.tokenStore = new TokenStore(tokenMap);
        this.variables = variables ? variables : {};
        this.behaviours["bpmn.StartEvent"] = this.behaviours["takeAll"];
        this.behaviours["bpmn.EndEvent"] = this.behaviours["takeNone"];
        this.behaviours["bpmn.UserTask"] = this.behaviours["takeNone"];
        this.behaviours["bpmn.ServiceTask"] = this.behaviours["takeAll"];
        this.behaviours["bpmn.ExclusiveGateway"] = this.behaviours["xor"];
        this.behaviours["bpmn.ParallelGateway"] = this.behaviours["and"];
      },
      behaviours: {
        "takeAll": function (element) {
          this.dropToken(element.id(), this.tokenStore);
          return element.outgoing();
        },
        "takeNone": function (element) {
          return [];
        },
        "xor": function (element) {
          this.dropToken(element.id(), this.tokenStore);
          if (element.outgoing().length == 1) {
            return element.outgoing();
          }
          var transition = null;
          _.map(element.outgoing(), function (outgoing) {
            var flowConfig = this.configuration[outgoing.id()];
            if (!transition && flowConfig && flowConfig(this)) {
              transition = outgoing;
            }
          }, this);
          if (!transition && !element.getDefault()) {
            throw new Error("No transition evaluated to true and no default defined");
          }
          return transition;
        },
        "and": function (element) {
          var isActive = true;
          var tokens = this.tokenStore.query(element.id());
          var fromMap = {};
          if (element.incoming().length == 1) {
            return _.bind(this.behaviours.takeAll, this)(element);
          }
          for (var index = 0; index < tokens.length; index++) {
            var token = tokens[index];
            fromMap[token.from] = token;
          }
          var activeTransitions = [];
          _.map(element.incoming(), function (incoming) {
            if (!fromMap[incoming.id()]) {
              isActive = false;
            } else {
              activeTransitions.push(incoming);
            }
          }, this);
          if (isActive) {
            _.map(activeTransitions, function (t) {
              _.bind(this.dropToken, this)(t.sourceRef(), this.tokenStore);
            }, this);
            return _.bind(this.behaviours.takeAll, this)(element);
          } else {
            return [];
          }
        }
      },
      dropToken: function (id, tokenStore, count) {
        if (tokenStore.query(id).length > 0) {
          tokenStore.drop(id, count ? count : 1);
        }
      },
      copyVariables: function (variables) {
        if (variables) {
          for (var index in variables) {
            this.variables[index] = variables[index];
          }
        }
      },
      start: function (startId, variables) {
        this.tokenStore.add(startId, { from: null });
        return this.trigger(startId, variables);
      },
      trigger: function (elementId, variables, behaviour, path) {
        console.log("trigger", elementId);
        var deferred = $.Deferred();
        var path = path ? path : $.Deferred();
        this.copyVariables(variables);
        var node = this.definitions.index.item(elementId);
        var nodeBehaviour = behaviour ? this.behaviours[behaviour] : this.behaviours[node.declaredClass];
        var transitions = [].concat(_.bind(nodeBehaviour, this)(node, this.tokenStore));
        console.log("next", transitions);
        if (transitions.length > 0 && this.configuration.leave) {
          this.configuration.leave(node);
          topic.publish("flow:leave:" + node.id(), node);
        }
        if (transitions.length == 0) {
          path.resolve();
        }
        transitions.map(function (transition) {
          this.tokenStore.add(transition.targetRef(), { from: transition.id() });
          var pubPath = "flow:enter:" + transition.targetRef();
          topic.publish(pubPath, transition.getTargetRef());
          if (this.configuration.enter) {
            this.configuration.enter(transition.getTargetRef());
          }
          var self = this;
          deferred.then(function () {
            console.log("then for", transition.id());
            self.trigger(transition.targetRef(), null, null, path);
          });
        }, this);
        if (this.configuration[elementId] && this.configuration[elementId]) {
          this.configuration[elementId]({
            instance: this,
            promise: deferred
          });
        } else {
          console.log("resolving", elementId, this.tokenStore.tokenMap);
          deferred.resolve();
        }
        return path;
      }
    };
  return new jsclass.Class(instance);


});
define('sax',[],function () {
  if (__isNode) {
  return __nodeRequire('sax');
} else {
  return (typeof sax !== 'undefined') ? sax : __nodeRequire('sax')
}
});
define('bpmn/util/Serializer',['require', 'exports', 'module', './JSClass', '../Package', '../Definitions', '../BaseElement', 'sax'], function (require, exports, module, jsclass, Package, Definitions, BaseElement) {
  

var serializer = {
      initialize: function () {
      },
      fromXML: function (xmlString) {
        if (!xmlString) {
          return;
        }
        var setAttributeFromNode = function (attrName, node, bpmnObj, type) {
          if (node.attributes[attrName]) {
            var value = node.attributes[attrName].value;
            if (type == "float") {
              value = parseFloat(value);
            }
            if (type == "boolean") {
              value = value.toLowerCase() == "true";
            }
            if (type == "integer") {
              value = parseInt(value);
            }
            bpmnObj[attrName](value);
          }
        };
        var parser = sax.parser(true, {
            xmlns: true,
            lowercase: true,
            trim: true
          });
        parser.stack = [];
        Array.prototype.peek = function () {
          return this.length == 0 ? null : this[this.length - 1];
        };
        var openTagHandlers = {
            "definitions": function (node) {
              parser.definitions = new Definitions();
              parser.stack.push(parser.definitions);
            },
            "default": function (node) {
              var parent = parser.stack.peek();
              var tagLookup = node.local.toLowerCase();
              var PackageClass = Package.tagMap[tagLookup];
              var newRef = PackageClass ? new PackageClass() : new BaseElement();
              parser.stack.push(newRef);
              newRef._definitions = parser.definitions;
              for (var attributeName in newRef.attribute) {
                setAttributeFromNode(attributeName, node, newRef, newRef.attribute[attributeName].type);
              }
              var refFound = null;
              for (var index in parent.reference) {
                var ref = parent.reference[index];
                if (newRef.isA(ref.type)) {
                  refFound = ref;
                  break;
                }
              }
              newRef.init();
              if (refFound && refFound.containment === true) {
                parent[refFound.name]().push(newRef);
              } else if (refFound) {
                parent[refFound.name](newRef);
              }
            }
          };
        parser.onerror = function (e) {
          console.log("error", e);
        };
        parser.onopentag = function (node) {
          if (openTagHandlers[node.local]) {
            openTagHandlers[node.local](node);
          } else {
            openTagHandlers["default"](node);
          }
        };
        parser.onclosetag = function (node) {
          parser.stack.pop();
        };
        parser.ontext = function (t) {
          parser.stack.peek().setText(t);
        };
        parser.onend = function () {
        };
        parser.write(xmlString).close();
        return parser.definitions;
      }
    };
  return new jsclass.Class(serializer);


});
define('kinetic',[],function () {
  if (__isNode) {
  return __nodeRequire('kinetic');
} else {
  return (typeof Kinetic !== 'undefined') ? Kinetic : __nodeRequire('kinetic')
}
});
define('bpmn/util/diagram/Canvas',['require', 'exports', 'module', 'kinetic'], function (require, exports, module, Kinetic) {
  

var Canvas = function Canvas(options) {
    this.scale = options.scale;
    var stage = this.stage = new Kinetic.Stage({
        container: options.container,
        width: options.width ? options.width : 500,
        height: options.height ? options.height : 500
      });
    stage.scale({
      x: this.scale,
      y: this.scale
    });
    this.shapeLayer = new Kinetic.Layer();
    this.connectionsLayer = new Kinetic.Layer();
    this.labelLayer = new Kinetic.Layer();
    stage.add(this.shapeLayer);
    stage.add(this.connectionsLayer);
    stage.add(this.labelLayer);
    this.createGroup = function (group) {
      return new Kinetic.Group(group);
    };
    this.createRect = function (rect) {
      return new Kinetic.Rect(rect);
    };
    this.createCircle = function (circle) {
      return new Kinetic.Circle(circle);
    };
    this.createLine = function (line) {
      return new Kinetic.Line(line);
    };
    this.createText = function (text) {
      return new Kinetic.Text(text);
    };
    this.createPolygon = function (polygon) {
      polygon.closed = true;
      return new Kinetic.Line(polygon);
    };
    this.createPath = function (path) {
      return new Kinetic.Path(path);
    };
    this.createArrowLine = function (points, lineOptions, size) {
      var headlen = size ? size : 6;
      var lastx = points[points.length - 2];
      var lasty = points[points.length - 1];
      var secondlastx = points[points.length - 4];
      var secondlasty = points[points.length - 3];
      var angle = Math.atan2(lasty - secondlasty, lastx - secondlastx);
      lineOptions.points = points.concat([
        lastx - headlen * Math.cos(angle - Math.PI / 6),
        lasty - headlen * Math.sin(angle - Math.PI / 6),
        lastx,
        lasty,
        lastx - headlen * Math.cos(angle + Math.PI / 6),
        lasty - headlen * Math.sin(angle + Math.PI / 6)
      ]);
      var line = new Kinetic.Line(lineOptions);
      return line;
    };
    this.expandCanvasIfNeeded = function (shape) {
      var buffer = 10;
      var x = shape.getX(), y = shape.getY(), width = shape.getWidth(), height = shape.getHeight();
      if ((x + width) * this.scale > this.stage.getWidth()) {
        this.stage.setWidth((x + width + buffer) * this.scale);
      }
      if ((y + height) * this.scale > this.stage.getHeight()) {
        this.stage.setHeight((y + height + buffer) * this.scale);
      }
    };
  };
  return Canvas;


});
define('bpmn/editor/ActivityRenderer',['require','exports','module'],function (require, exports, module) {
  

var ActivityRenderer = function (renderer) {
    this.markerPaths = {
      "bpmn.ServiceTask": "m 22.701284,14.663851 c 0.432742,0 0.835353,-0.363368 0.894226,-0.807377 0,0 0.08274,-0.624013 0.08274,-1.366108 0,-0.742094 -0.08274,-1.366107 -0.08274,-1.366107 -0.05909,-0.444249 -0.461484,-0.807376 -0.894226,-0.807376 h -2.236261 c -0.432975,0 -0.882637,-0.285846 -0.998992,-0.6350536 -0.116355,-0.3492066 -0.276519,-1.4695496 0.02967,-1.7863558 L 21.076473,6.2586397 C 21.382428,5.9415935 21.40607,5.4006221 21.128856,5.0562152 L 19.269014,3.1299359 C 18.936402,2.8426498 18.414191,2.8671302 18.107771,3.1841824 L 16.526998,4.8210152 C 16.221042,5.1380613 15.710883,5.2657441 15.394032,5.1049407 15.076952,4.9441373 14.18852,4.2658838 14.18852,3.8175543 V 1.501988 c 0,-0.4483294 -0.350922,-0.86497745 -0.779725,-0.92617905 0,0 -0.60264,-0.085927 -1.319319,-0.085927 -0.716679,0 -1.319319,0.085927 -1.319319,0.085927 -0.429034,0.06096 -0.7799559,0.47784965 -0.7799559,0.92617905 v 2.3155663 c 0,0.4483295 -0.275824,0.9136994 -0.6133031,1.0344211 C 9.0394192,4.9724583 7.9576789,5.1383013 7.6514912,4.8212576 L 6.0707181,3.1844175 C 5.7645304,2.8673702 5.2420872,2.8428899 4.9097076,3.1299359 L 3.0496339,5.0559751 C 2.7721873,5.4003821 2.7958294,5.9413535 3.1020167,6.2583996 L 4.682558,7.8952336 C 4.9887458,8.2122798 5.1122872,8.7402903 4.9567595,9.0683769 4.8012323,9.3964637 4.14644,10.316643 3.7134658,10.316643 H 1.4774369 c -0.4329742,0 -0.83535274,0.363367 -0.89445788,0.807376 0,0 -0.082979,0.624013 -0.082979,1.366107 0,0.742335 0.082979,1.366108 0.082979,1.366108 0.0588733,0.444249 0.46148368,0.807376 0.89445788,0.807376 h 2.2362607 c 0.4329742,0 0.882405,0.285607 0.9987611,0.635054 0.116356,0.349206 0.2765193,1.46931 -0.029668,1.786356 l -1.5805412,1.636594 c -0.3061877,0.317046 -0.3298298,0.858017 -0.052384,1.202424 l 1.859842,1.926279 c 0.3326113,0.287047 0.8548228,0.262806 1.1610105,-0.05425 l 1.5807733,-1.636829 c 0.3061877,-0.316806 0.8161146,-0.444729 1.1331963,-0.283925 0.3170817,0.160802 1.2055136,0.839057 1.2055136,1.287386 v 2.315567 c 0,0.448089 0.3509218,0.864976 0.7799558,0.925938 0,0 0.602408,0.08568 1.319319,0.08568 0.71691,0 1.319319,-0.08568 1.319319,-0.08568 0.429035,-0.06119 0.779725,-0.477849 0.779725,-0.925938 v -2.315567 c 0,-0.448329 0.275825,-0.913939 0.613303,-1.034421 0.337479,-0.120482 1.419219,-0.286086 1.725407,0.03071 l 1.580541,1.636833 c 0.306188,0.316807 0.828631,0.341288 1.161243,0.05425 l 1.859842,-1.925559 c 0.277214,-0.344407 0.253804,-0.885138 -0.05262,-1.202424 l -1.58054,-1.636586 c -0.306188,-0.317046 -0.42973,-0.845056 -0.274202,-1.173383 0.155296,-0.328327 0.81032,-1.248266 1.243294,-1.248266 h 2.236492 z m -10.612039,2.218844 c -2.342882,0 -4.2421275,-1.966359 -4.2421275,-4.392569 0,-2.425728 1.8992455,-4.3925682 4.2421275,-4.3925682 2.342882,0 4.242127,1.9666002 4.242127,4.3925682 0,2.42597 -1.899245,4.392569 -4.242127,4.392569 z",
      "bpmn.UserTask": "M 12.253681,11.77491 C 11.634895,10.657313 10.877364,9.7523027 10.117807,9.1196049 9.2316574,9.7684998 8.152074,10.163303 6.9752673,10.163303 5.7964351,10.163303 4.715839,9.7674875 3.8307021,9.1196049 3.0711453,9.7523027 2.313614,10.657313 1.6928029,11.77491 c -1.44011956,2.594568 -1.59810737,5.255948 -0.3544598,5.946348 0.5570083,0.310781 1.1413607,0.07896 1.7449552,-0.502109 -0.106338,0.589168 -0.1681153,1.22794 -0.1681153,1.896068 0,2.968112 1.1535136,5.372364 2.5754039,5.372364 0.8567801,0 1.2811192,-0.875654 1.4846804,-2.215961 0.2035612,1.340307 0.6279003,2.215961 1.4816421,2.215961 1.4239158,0 2.5774296,-2.404252 2.5774296,-5.372364 0,-0.668128 -0.06178,-1.3069 -0.170141,-1.896068 0.60562,0.581069 1.18896,0.81289 1.746981,0.502109 1.243647,-0.6904 1.082621,-3.35178 -0.357498,-5.946348 z M 6.9742546,9.1509867 c 2.3920975,0 4.3325124,-1.9395984 4.3325124,-4.3317023 0,-2.3921039 -1.9404149,-4.33170228 -4.3325124,-4.33170228 -2.3931103,0 -4.3345375,1.93959838 -4.3345375,4.33170228 0,2.3921039 1.9414272,4.3317023 4.3345375,4.3317023 z",
      "bpmn.BusinessRuleTask": "M 0.49999997,0.68485673 V 3.8369982 H 24.501049 V 0.68485673 H 0.49999997 z m 0,17.05141427 H 24.501049 V 14.58413 H 0.49999997 v 3.152141 z m 0,-6.949637 H 24.501049 V 7.6344932 H 0.49999997 v 3.1521408 z m 0,13.898223 H 24.501049 V 21.532715 H 0.49999997 v 3.152142 z",
      "bpmn.ReceiveTask": "M 1.7164479,0.59270005 9.5482144,6.784475 17.408905,0.54332386 z M 0.70000001,1.254341 l 0,11.06027 17.69642899,0 0,-11.06027 -8.8482146,6.6361608 z"
    };
    this.createRectangle = function (bounds) {
      var cornerRadius = renderer.skin()["activity_corner_radius"];
      var rect = renderer.canvas.createRect({
          width: bounds.width(),
          height: bounds.height(),
          "cornerRadius": cornerRadius,
          stroke: renderer.skin()["activity_stroke"],
          fill: renderer.skin()["activity_fill"],
          strokeWidth: 2
        });
      return rect;
    };
    this.getPathForActivityType = function (activity) {
      return this.markerPaths[activity.declaredClass];
    };
    this.createMarker = function (pathForType) {
      var activityMarker = renderer.canvas.createPath({
          x: 3,
          y: 3,
          data: pathForType,
          stroke: renderer.skin()["activity_stroke"],
          fill: renderer.skin()["activity_fill"],
          scale: 0.6
        });
      return activityMarker;
    };
    this.render = function (activity, group) {
      var bounds = activity.getBounds();
      var rect = this.createRectangle(bounds);
      var pathForType = this.getPathForActivityType(activity);
      var activityMarker = this.createMarker(pathForType);
      group.add(rect);
      group.add(activityMarker);
      return group;
    };
  };
  return ActivityRenderer;


});
define('bpmn/editor/EventRenderer',['require','exports','module'],function (require, exports, module) {
  

var EventRenderer = function () {
    this.render = function (event, group) {
      var bounds = event.getBounds();
      var circle = this.canvas.createCircle({
          width: bounds.width(),
          height: bounds.height(),
          stroke: this.skin()["event_stroke"],
          strokeWidth: 2,
          draggable: true
        });
      group.add(circle);
      return group;
    };
  };
  return EventRenderer;


});
define('bpmn/editor/GatewayRenderer',['require','exports','module'],function (require, exports, module) {
  

var GatewayRenderer = function () {
    this.render = function (gateway, group) {
      var bounds = gateway.getBounds();
      var rect = this.canvas.createPolygon({
          points: [
            0,
            bounds.height() / 2,
            bounds.width() / 2,
            0,
            bounds.width(),
            bounds.height() / 2,
            bounds.width() / 2,
            bounds.height()
          ],
          stroke: "black",
          fill: "white",
          strokeWidth: 2,
          draggable: true
        });
      group.add(rect);
      return group;
    };
  };
  return GatewayRenderer;


});
define('bpmn/editor/LabelRenderer',['require','exports','module'],function (require, exports, module) {
  

var Label = function (renderer) {
    this.renderCentered = function (bounds, group, labelText) {
      var text = this.createLabelText(labelText);
      text.setY(bounds.height() / 2 - text.getFontSize());
      text.setWidth(bounds.width());
      group.add(text);
      return group;
    };
    this.createLabelText = function (text) {
      return renderer.canvas.createText({
        text: text,
        fontSize: renderer.skin()["label_font_size"],
        fontFamily: renderer.skin()["label_font_family"],
        fill: renderer.skin()["label_fill"],
        align: "center"
      });
    };
  };
  return Label;


});
define('bpmn/editor/Renderer',['require', 'exports', 'module', '../util/JSClass', 'lodash', '../Activity', '../Gateway', '../Event', '../SequenceFlow', '../util/diagram/Canvas', './ActivityRenderer', './EventRenderer', './GatewayRenderer', './LabelRenderer'], function (require, exports, module, jsclass, _, Activity, Gateway, Event, SequenceFlow, Canvas, ActivityRenderer, EventRenderer, GatewayRenderer, LabelRenderer) {
  

var Renderer = {
      skins: {
        "default": {
          "event_stroke": "black",
          "activity_stroke": "black",
          "activity_fill": "white",
          "activity_corner_radius": 10,
          "label_font_family": "Arial",
          "label_font_size": 12,
          "label_fill": "black"
        }
      },
      initialize: function (definitions, options) {
        this.definitions = definitions;
        this.skinName = "default";
        this.bindDelegates();
        this.evaluateOptionsAndDefaults(options);
        this.canvas = new Canvas(this.options);
      },
      bindDelegates: function () {
        this.activity = new ActivityRenderer(this);
        this.renderEvent = new EventRenderer().render;
        this.renderGateway = new GatewayRenderer().render;
        this.label = new LabelRenderer(this);
      },
      evaluateOptionsAndDefaults: function (options) {
        this.options = options;
        this.skinName = options.skin ? options.skin : "default";
        this.options.scale = options.scale ? options.scale : 1;
      },
      render: function () {
        this.renderElements();
        this.canvas.shapeLayer.draw();
        this.canvas.connectionsLayer.draw();
        this.canvas.labelLayer.draw();
      },
      renderElements: function () {
        if (this.definitions.process().length > 1) {
          throw new Error("Only single process models are supported");
        }
        _.forEach(this.definitions.process(), function (process) {
          _.forEach(process.flowElements(), function (flowElement) {
            this.renderElement(flowElement);
          }, this);
        }, this);
      },
      renderElement: function (element) {
        var group = this.canvas.createGroup({ draggable: true });
        if (element instanceof SequenceFlow) {
          this.renderConnection(element, group);
          this.canvas.connectionsLayer.add(group);
        } else if (element instanceof Activity) {
          this.label.renderCentered(element.getBounds(), this.activity.render(element, group), element.name());
          this.canvas.shapeLayer.add(group);
          this.setGroupBounds(group, element.getBounds());
        } else if (element instanceof Event) {
          this.renderEvent(element, group);
          this.canvas.shapeLayer.add(group);
          this.setGroupBounds(group, this.eventBounds(element));
        } else if (element instanceof Gateway) {
          this.renderGateway(element, group);
          this.canvas.shapeLayer.add(group);
          this.setGroupBounds(group, element.getBounds());
        } else {
          console.log("unable to render flowElement", element);
        }
        this.canvas.expandCanvasIfNeeded(group);
      },
      eventBounds: function (eventElement) {
        var bounds = eventElement.getBounds();
        return {
          x: function () {
            return bounds.x() + bounds.width() / 2;
          },
          y: function () {
            return bounds.y() + bounds.height() / 2;
          },
          width: function () {
            return bounds.width();
          },
          height: function () {
            return bounds.height();
          }
        };
      },
      setGroupBounds: function (group, bounds) {
        group.setX(bounds.x());
        group.setY(bounds.y());
        group.setWidth(bounds.width());
        group.setHeight(bounds.height());
      },
      renderConnection: function (connection, group) {
        var joinedPoints = [];
        _.forEach(connection.getWaypoints(), function (point) {
          joinedPoints.push(point.x);
          joinedPoints.push(point.y);
        });
        var arrow = this.canvas.createArrowLine(joinedPoints, {
            stroke: "black",
            strokeWidth: 2,
            lineCap: "round",
            lineJoin: "round"
          });
        group.add(arrow);
        return group;
      },
      skin: function () {
        return this.skins[this.skinName];
      }
    };
  return new jsclass.Class(Renderer);


});
define('bpmn/Bpmn',['require', 'exports', 'module', './util/JSClass', './Definitions', './execution/Instance', './util/Serializer', './editor/Renderer'], function (require, exports, module, jsclass, Definitions, Instance, Serializer, Renderer) {
  

var bpmn = {
      initialize: function () {
        this.serializer = new Serializer();
      },
      renderer: function (definitions, options) {
        return new Renderer(definitions, options);
      },
      fromXML: function (bpmnXml) {
        return this.serializer.fromXML(bpmnXml);
      }
    };
  return new jsclass.Class(bpmn);


});
    return require('bpmn/Bpmn');
  };
if (__isAMD) {
  return define(['sax', 'kinetic', 'jquery', 'lodash'], bundleFactory);
} else {
    if (__isNode) {
        return module.exports = bundleFactory(require('sax'), require('kinetic'), require('jquery'), require('lodash'));
    } else {
        return bundleFactory((typeof sax !== 'undefined') ? sax : void 0, (typeof Kinetic !== 'undefined') ? Kinetic : void 0, (typeof $ !== 'undefined') ? $ : void 0, (typeof _ !== 'undefined') ? _ : void 0);
    }
}
}).call(this, (typeof exports === 'object' ? global : window),
              (typeof exports === 'object' ? global : window))