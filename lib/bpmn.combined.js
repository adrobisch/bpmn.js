// Generated by uRequire v0.6.15 - template: 'combined' 
// Combined template optimized with RequireJS/r.js v2.1.13 & almond.
(function (global, window){
  
var __isAMD = !!(typeof define === 'function' && define.amd),
    __isNode = (typeof exports === 'object'),
    __isWeb = !__isNode;

  var __nodeRequire = (__isNode ? require :
      function(dep){
        throw new Error("uRequire detected missing dependency: '" + dep + "' - in a non-nodejs runtime. All it's binding variables were 'undefined'.")
      });
var bundleFactory = function(sax, $, _, fabric) {/**
 * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                name = baseParts.concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("almond", function(){});

define('bpmn/util/JSClass',['require','exports','module'],function (require, exports, module) {
  

var JS = typeof this.JS === "undefined" ? {} : this.JS;
(function (factory) {
  var $ = typeof this.global === "object" ? this.global : this, E = typeof exports === "object";
  if (E) {
    exports.JS = exports;
    JS = exports;
  } else {
    $.JS = JS;
  }
  factory($, JS);
}(function (global, exports) {
  "use strict";
  var JS = { ENV: global };
  JS.END_WITHOUT_DOT = /([^\.])$/;
  JS.array = function (enumerable) {
    var array = [], i = enumerable.length;
    while (i--)
      array[i] = enumerable[i];
    return array;
  };
  JS.bind = function (method, object) {
    return function () {
      return method.apply(object, arguments);
    };
  };
  JS.Date = JS.ENV.Date;
  JS.extend = function (destination, source, overwrite) {
    if (!destination || !source)
      return destination;
    for (var field in source) {
      if (destination[field] === source[field])
        continue;
      if (overwrite === false && destination.hasOwnProperty(field))
        continue;
      destination[field] = source[field];
    }
    return destination;
  };
  JS.indexOf = function (list, item) {
    if (list.indexOf)
      return list.indexOf(item);
    var i = list.length;
    while (i--) {
      if (list[i] === item)
        return i;
    }
    return -1;
  };
  JS.isType = function (object, type) {
    if (typeof type === "string")
      return typeof object === type;
    if (object === null || object === undefined)
      return false;
    return typeof type === "function" && object instanceof type || object.isA && object.isA(type) || object.constructor === type;
  };
  JS.makeBridge = function (parent) {
    var bridge = function () {
    };
    bridge.prototype = parent.prototype;
    return new bridge();
  };
  JS.makeClass = function (parent) {
    parent = parent || Object;
    var constructor = function () {
      return this.initialize ? this.initialize.apply(this, arguments) || this : this;
    };
    constructor.prototype = JS.makeBridge(parent);
    constructor.superclass = parent;
    constructor.subclasses = [];
    if (parent.subclasses)
      parent.subclasses.push(constructor);
    return constructor;
  };
  JS.match = function (category, object) {
    if (object === undefined)
      return false;
    return typeof category.test === "function" ? category.test(object) : category.match(object);
  };
  JS.Method = JS.makeClass();
  JS.extend(JS.Method.prototype, {
    initialize: function (module, name, callable) {
      this.module = module;
      this.name = name;
      this.callable = callable;
      this._words = {};
      if (typeof callable !== "function")
        return;
      this.arity = callable.length;
      var matches = callable.toString().match(/\b[a-z\_\$][a-z0-9\_\$]*\b/gi), i = matches.length;
      while (i--)
        this._words[matches[i]] = true;
    },
    setName: function (name) {
      this.callable.displayName = this.displayName = name;
    },
    contains: function (word) {
      return this._words.hasOwnProperty(word);
    },
    call: function () {
      return this.callable.call.apply(this.callable, arguments);
    },
    apply: function (receiver, args) {
      return this.callable.apply(receiver, args);
    },
    compile: function (environment) {
      var method = this, trace = method.module.__trace__ || environment.__trace__, callable = method.callable, words = method._words, allWords = JS.Method._keywords, i = allWords.length, keywords = [], keyword;
      while (i--) {
        keyword = allWords[i];
        if (words[keyword.name])
          keywords.push(keyword);
      }
      if (keywords.length === 0 && !trace)
        return callable;
      var compiled = function () {
        var N = keywords.length, j = N, previous = {}, keyword, existing, kwd;
        while (j--) {
          keyword = keywords[j];
          existing = this[keyword.name];
          if (existing && !existing.__kwd__)
            continue;
          previous[keyword.name] = {
            _value: existing,
            _own: this.hasOwnProperty(keyword.name)
          };
          kwd = keyword.filter(method, environment, this, arguments);
          if (kwd)
            kwd.__kwd__ = true;
          this[keyword.name] = kwd;
        }
        var returnValue = callable.apply(this, arguments), j = N;
        while (j--) {
          keyword = keywords[j];
          if (!previous[keyword.name])
            continue;
          if (previous[keyword.name]._own)
            this[keyword.name] = previous[keyword.name]._value;
          else
            delete this[keyword.name];
        }
        return returnValue;
      };
      return compiled;
    },
    toString: function () {
      var name = this.displayName || this.module.toString() + "#" + this.name;
      return "#<Method:" + name + ">";
    }
  });
  JS.Method.create = function (module, name, callable) {
    if (callable && callable.__inc__ && callable.__fns__)
      return callable;
    var method = typeof callable !== "function" ? callable : new this(module, name, callable);
    this.notify(method);
    return method;
  };
  JS.Method.compile = function (method, environment) {
    return method instanceof this ? method.compile(environment) : method;
  };
  JS.Method.__listeners__ = [];
  JS.Method.added = function (block, context) {
    this.__listeners__.push([
      block,
      context
    ]);
  };
  JS.Method.notify = function (method) {
    var listeners = this.__listeners__, i = listeners.length, listener;
    while (i--) {
      listener = listeners[i];
      listener[0].call(listener[1], method);
    }
  };
  JS.Method._keywords = [];
  JS.Method.keyword = function (name, filter) {
    this._keywords.push({
      name: name,
      filter: filter
    });
  };
  JS.Method.trace = function (classes) {
    var i = classes.length;
    while (i--) {
      classes[i].__trace__ = true;
      classes[i].resolve();
    }
  };
  JS.Method.untrace = function (classes) {
    var i = classes.length;
    while (i--) {
      classes[i].__trace__ = false;
      classes[i].resolve();
    }
  };
  JS.Module = JS.makeClass();
  JS.Module.__queue__ = [];
  JS.extend(JS.Module.prototype, {
    initialize: function (name, methods, options) {
      if (typeof name !== "string") {
        options = arguments[1];
        methods = arguments[0];
        name = undefined;
      }
      options = options || {};
      this.__inc__ = [];
      this.__dep__ = [];
      this.__fns__ = {};
      this.__tgt__ = options._target;
      this.__anc__ = null;
      this.__mct__ = {};
      this.setName(name);
      this.include(methods, { _resolve: false });
      if (JS.Module.__queue__)
        JS.Module.__queue__.push(this);
    },
    setName: function (name) {
      this.displayName = name || "";
      for (var field in this.__fns__)
        this.__name__(field);
      if (name && this.__meta__)
        this.__meta__.setName(name + ".");
    },
    __name__: function (name) {
      if (!this.displayName)
        return;
      var object = this.__fns__[name];
      if (!object)
        return;
      name = this.displayName.replace(JS.END_WITHOUT_DOT, "$1#") + name;
      if (typeof object.setName === "function")
        return object.setName(name);
      if (typeof object === "function")
        object.displayName = name;
    },
    define: function (name, callable, options) {
      var method = JS.Method.create(this, name, callable), resolve = (options || {})._resolve;
      this.__fns__[name] = method;
      this.__name__(name);
      if (resolve !== false)
        this.resolve();
    },
    include: function (module, options) {
      if (!module)
        return this;
      var options = options || {}, resolve = options._resolve !== false, extend = module.extend, include = module.include, extended, field, value, mixins, i, n;
      if (module.__fns__ && module.__inc__) {
        this.__inc__.push(module);
        if ((module.__dep__ || {}).push)
          module.__dep__.push(this);
        if (extended = options._extended) {
          if (typeof module.extended === "function")
            module.extended(extended);
        } else {
          if (typeof module.included === "function")
            module.included(this);
        }
      } else {
        if (this.shouldIgnore("extend", extend)) {
          mixins = [].concat(extend);
          for (i = 0, n = mixins.length; i < n; i++)
            this.extend(mixins[i]);
        }
        if (this.shouldIgnore("include", include)) {
          mixins = [].concat(include);
          for (i = 0, n = mixins.length; i < n; i++)
            this.include(mixins[i], { _resolve: false });
        }
        for (field in module) {
          if (!module.hasOwnProperty(field))
            continue;
          value = module[field];
          if (this.shouldIgnore(field, value))
            continue;
          this.define(field, value, { _resolve: false });
        }
        if (module.hasOwnProperty("toString"))
          this.define("toString", module.toString, { _resolve: false });
      }
      if (resolve)
        this.resolve();
      return this;
    },
    alias: function (aliases) {
      for (var method in aliases) {
        if (!aliases.hasOwnProperty(method))
          continue;
        this.define(method, this.instanceMethod(aliases[method]), { _resolve: false });
      }
      this.resolve();
    },
    resolve: function (host) {
      var host = host || this, target = host.__tgt__, inc = this.__inc__, fns = this.__fns__, i, n, key, compiled;
      if (host === this) {
        this.__anc__ = null;
        this.__mct__ = {};
        i = this.__dep__.length;
        while (i--)
          this.__dep__[i].resolve();
      }
      if (!target)
        return;
      for (i = 0, n = inc.length; i < n; i++)
        inc[i].resolve(host);
      for (key in fns) {
        compiled = JS.Method.compile(fns[key], host);
        if (target[key] !== compiled)
          target[key] = compiled;
      }
      if (fns.hasOwnProperty("toString"))
        target.toString = JS.Method.compile(fns.toString, host);
    },
    shouldIgnore: function (field, value) {
      return (field === "extend" || field === "include") && (typeof value !== "function" || value.__fns__ && value.__inc__);
    },
    ancestors: function (list) {
      var cachable = !list, list = list || [], inc = this.__inc__;
      if (cachable && this.__anc__)
        return this.__anc__.slice();
      for (var i = 0, n = inc.length; i < n; i++)
        inc[i].ancestors(list);
      if (JS.indexOf(list, this) < 0)
        list.push(this);
      if (cachable)
        this.__anc__ = list.slice();
      return list;
    },
    lookup: function (name) {
      var cached = this.__mct__[name];
      if (cached && cached.slice)
        return cached.slice();
      var ancestors = this.ancestors(), methods = [], fns;
      for (var i = 0, n = ancestors.length; i < n; i++) {
        fns = ancestors[i].__fns__;
        if (fns.hasOwnProperty(name))
          methods.push(fns[name]);
      }
      this.__mct__[name] = methods.slice();
      return methods;
    },
    includes: function (module) {
      if (module === this)
        return true;
      var inc = this.__inc__;
      for (var i = 0, n = inc.length; i < n; i++) {
        if (inc[i].includes(module))
          return true;
      }
      return false;
    },
    instanceMethod: function (name) {
      return this.lookup(name).pop();
    },
    instanceMethods: function (recursive, list) {
      var methods = list || [], fns = this.__fns__, field;
      for (field in fns) {
        if (!JS.isType(this.__fns__[field], JS.Method))
          continue;
        if (JS.indexOf(methods, field) >= 0)
          continue;
        methods.push(field);
      }
      if (recursive !== false) {
        var ancestors = this.ancestors(), i = ancestors.length;
        while (i--)
          ancestors[i].instanceMethods(false, methods);
      }
      return methods;
    },
    match: function (object) {
      return object && object.isA && object.isA(this);
    },
    toString: function () {
      return this.displayName;
    }
  });
  JS.Kernel = new JS.Module("Kernel", {
    __eigen__: function () {
      if (this.__meta__)
        return this.__meta__;
      var name = this.toString() + ".";
      this.__meta__ = new JS.Module(name, null, { _target: this });
      return this.__meta__.include(this.klass, { _resolve: false });
    },
    equals: function (other) {
      return this === other;
    },
    extend: function (module, options) {
      var resolve = (options || {})._resolve;
      this.__eigen__().include(module, {
        _extended: this,
        _resolve: resolve
      });
      return this;
    },
    hash: function () {
      return JS.Kernel.hashFor(this);
    },
    isA: function (module) {
      return typeof module === "function" && this instanceof module || this.__eigen__().includes(module);
    },
    method: function (name) {
      var cache = this.__mct__ = this.__mct__ || {}, value = cache[name], field = this[name];
      if (typeof field !== "function")
        return field;
      if (value && field === value._value)
        return value._bound;
      var bound = JS.bind(field, this);
      cache[name] = {
        _value: field,
        _bound: bound
      };
      return bound;
    },
    methods: function () {
      return this.__eigen__().instanceMethods();
    },
    tap: function (block, context) {
      block.call(context, this);
      return this;
    },
    toString: function () {
      if (this.displayName)
        return this.displayName;
      var name = this.klass.displayName || this.klass.toString();
      return "#<" + name + ":" + this.hash() + ">";
    }
  });
  (function () {
    var id = 1;
    JS.Kernel.hashFor = function (object) {
      if (object.__hash__ !== undefined)
        return object.__hash__;
      object.__hash__ = (new JS.Date().getTime() + id).toString(16);
      id += 1;
      return object.__hash__;
    };
  }());
  JS.Class = JS.makeClass(JS.Module);
  JS.extend(JS.Class.prototype, {
    initialize: function (name, parent, methods, options) {
      if (typeof name !== "string") {
        options = arguments[2];
        methods = arguments[1];
        parent = arguments[0];
        name = undefined;
      }
      if (typeof parent !== "function") {
        options = methods;
        methods = parent;
        parent = Object;
      }
      JS.Module.prototype.initialize.call(this, name);
      options = options || {};
      var klass = JS.makeClass(parent);
      JS.extend(klass, this);
      klass.prototype.constructor = klass.prototype.klass = klass;
      klass.__eigen__().include(parent.__meta__, { _resolve: options._resolve });
      klass.setName(name);
      klass.__tgt__ = klass.prototype;
      var parentModule = parent === Object ? {} : parent.__fns__ ? parent : new JS.Module(parent.prototype, { _resolve: false });
      klass.include(JS.Kernel, { _resolve: false }).include(parentModule, { _resolve: false }).include(methods, { _resolve: false });
      if (options._resolve !== false)
        klass.resolve();
      if (typeof parent.inherited === "function")
        parent.inherited(klass);
      return klass;
    }
  });
  (function () {
    var methodsFromPrototype = function (klass) {
      var methods = {}, proto = klass.prototype;
      for (var field in proto) {
        if (!proto.hasOwnProperty(field))
          continue;
        methods[field] = JS.Method.create(klass, field, proto[field]);
      }
      return methods;
    };
    var classify = function (name, parentName) {
      var klass = JS[name], parent = JS[parentName];
      klass.__inc__ = [];
      klass.__dep__ = [];
      klass.__fns__ = methodsFromPrototype(klass);
      klass.__tgt__ = klass.prototype;
      klass.prototype.constructor = klass.prototype.klass = klass;
      JS.extend(klass, JS.Class.prototype);
      klass.include(parent || JS.Kernel);
      klass.setName(name);
      klass.constructor = klass.klass = JS.Class;
    };
    classify("Method");
    classify("Module");
    classify("Class", "Module");
    var eigen = JS.Kernel.instanceMethod("__eigen__");
    eigen.call(JS.Method).resolve();
    eigen.call(JS.Module).resolve();
    eigen.call(JS.Class).include(JS.Module.__meta__);
  }());
  JS.NotImplementedError = new JS.Class("NotImplementedError", Error);
  JS.Method.keyword("callSuper", function (method, env, receiver, args) {
    var methods = env.lookup(method.name), stackIndex = methods.length - 1, params = JS.array(args);
    if (stackIndex === 0)
      return undefined;
    var _super = function () {
      var i = arguments.length;
      while (i--)
        params[i] = arguments[i];
      stackIndex -= 1;
      if (stackIndex === 0)
        delete receiver.callSuper;
      var returnValue = methods[stackIndex].apply(receiver, params);
      receiver.callSuper = _super;
      stackIndex += 1;
      return returnValue;
    };
    return _super;
  });
  JS.Method.keyword("blockGiven", function (method, env, receiver, args) {
    var block = Array.prototype.slice.call(args, method.arity), hasBlock = typeof block[0] === "function";
    return function () {
      return hasBlock;
    };
  });
  JS.Method.keyword("yieldWith", function (method, env, receiver, args) {
    var block = Array.prototype.slice.call(args, method.arity);
    return function () {
      if (typeof block[0] !== "function")
        return;
      return block[0].apply(block[1] || null, arguments);
    };
  });
  JS.Interface = new JS.Class("Interface", {
    initialize: function (methods) {
      this.test = function (object, returnName) {
        var n = methods.length;
        while (n--) {
          if (typeof object[methods[n]] !== "function")
            return returnName ? methods[n] : false;
        }
        return true;
      };
    },
    extend: {
      ensure: function () {
        var args = JS.array(arguments), object = args.shift(), face, result;
        while (face = args.shift()) {
          result = face.test(object, true);
          if (result !== true)
            throw new Error("object does not implement " + result + "()");
        }
      }
    }
  });
  JS.Singleton = new JS.Class("Singleton", {
    initialize: function (name, parent, methods) {
      return new new JS.Class(name, parent, methods)();
    }
  });
  JS.extend(exports, JS);
  if (global.JS)
    JS.extend(global.JS, JS);
}));

return module.exports;

});
define('bpmn/util/Index',['require', 'exports', 'module', './JSClass'], function (require, exports, module, jsclass) {
  

var index = {
      initialize: function () {
        this._ = {};
      },
      add: function (key, value) {
        this._[key] = value;
      },
      addArray: function (key, value) {
        if (!this._[key]) {
          this._[key] = [];
        }
        this._[key].push(value);
      },
      addMap: function (key, property, value) {
        if (!this._[key]) {
          this._[key] = {};
        }
        this._[key][property] = value;
      },
      item: function (key) {
        return this._[key];
      }
    };
  return new jsclass.Class(index);


});
define('bpmn/Clazz',['require', 'exports', 'module', './util/JSClass'], function (require, exports, module, jsclass) {
  

var clazz = {
      initialize: function () {
        this.text = null;
        this.reference = {};
        this.attribute = {};
      },
      addReference: function (ref) {
        this.reference[ref.name] = ref;
        var name = this.__internalFieldName(ref.name);
        if (ref.containment === true) {
          this[name] = [];
        } else {
          this[name] = null;
        }
        this[ref.name] = function (newValue) {
          return this.accessor(ref.name, newValue);
        };
      },
      addAttribute: function (attr) {
        this.attribute[attr.name] = attr;
        this[attr.name] = function (newValue) {
          return this.accessor(attr.name, newValue);
        };
      },
      accessor: function (field, newValue) {
        var name = this.__internalFieldName(field);
        if (newValue != null && newValue != undefined) {
          this[name] = newValue;
        }
        return this[name];
      },
      __internalFieldName: function (field) {
        return "_" + field;
      },
      init: function () {
      },
      setText: function (text) {
        this.text = text;
      }
    };
  return new jsclass.Class(clazz);


});
define('bpmn/BaseElement',['require', 'exports', 'module', './util/JSClass', './Clazz'], function (require, exports, module, jsclass, Clazz) {
  

var baseElement = {
      tag: "baseElement",
      initialize: function () {
        this.callSuper();
        this.addReference({
          name: "documentation",
          type: function Documentation() {
          }
        });
        this.addAttribute({
          name: "id",
          type: String
        });
        this.addAttribute({
          name: "name",
          type: String
        });
        var uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
            return v.toString(16);
          });
        this.id(uuid);
      },
      init: function () {
        var id = this.id();
        this._definitions.index.add(id, this);
        this._definitions.index.addMap(this.declaredClass, id, this);
      }
    };
  return new jsclass.Class(Clazz, baseElement);


});
define('bpmn/CallableElement',['require', 'exports', 'module', './util/JSClass', './BaseElement'], function (require, exports, module, jsclass, BaseElement) {
  

var callableElement = {
      initialize: function () {
        this.callSuper();
        this.addAttribute({
          name: "name",
          type: String
        });
      },
      init: function () {
        this.callSuper();
      }
    };
  return new jsclass.Class(BaseElement, callableElement);


});
define('bpmn/Package',['require', 'exports', 'module', './util/JSClass'], function (require, exports, module, jsclass) {
  

var packageDef = {
      tagMap: {},
      initialize: function () {
      },
      registerClass: function (newClass) {
        var tag = newClass.prototype.tag;
        if (tag) {
          this.tagMap[tag.toLowerCase()] = newClass;
        }
        return newClass;
      }
    };
  var Package = new jsclass.Class(packageDef);
  return new Package();


});
define('bpmn/FlowElement',['require', 'exports', 'module', './util/JSClass', './BaseElement', './Package'], function (require, exports, module, jsclass, BaseElement, Package) {
  

var flowElement = {
      tag: "flowElement",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      },
      getDiagramElement: function () {
        return this._definitions.index.item(this.id() + ":di");
      },
      getBounds: function () {
        return this.getDiagramElement().bounds();
      },
      getWaypoints: function () {
        return this.getDiagramElement().waypoints();
      }
    };
  var FlowElementClass = new jsclass.Class(BaseElement, flowElement);
  Package.registerClass(FlowElementClass);
  return FlowElementClass;


});
define('bpmn/FlowElementsContainer',['require', 'exports', 'module', './util/JSClass', './BaseElement', './FlowElement'], function (require, exports, module, jsclass, BaseElement, FlowElement) {
  

var flowElementsContainer = {
      initialize: function () {
        this.callSuper();
        this.addReference({
          name: "flowElements",
          containment: true,
          type: FlowElement
        });
      },
      init: function () {
        this.callSuper();
      }
    };
  return new jsclass.Module(flowElementsContainer);


});
define('bpmn/Process',['require', 'exports', 'module', './util/JSClass', './CallableElement', './FlowElementsContainer', './Package'], function (require, exports, module, jsclass, CallableElement, FlowElementsContainer, Package) {
  

var process = {
      include: [FlowElementsContainer],
      tag: "process",
      initialize: function () {
        this.callSuper();
        this.addAttribute({
          name: "isExecutable",
          type: "boolean"
        });
        this.addAttribute({
          name: "name",
          type: String
        });
      }
    };
  var processClass = new jsclass.Class(CallableElement, process);
  return Package.registerClass(processClass);


});
define('bpmn/Collaboration',['require', 'exports', 'module', './util/JSClass', './Package'], function (require, exports, module, jsclass, Package) {
  

var collaboration = {
      tag: "collaboration",
      initialize: function () {
      }
    };
  var CollaborationClass = new jsclass.Class(collaboration);
  Package.registerClass(CollaborationClass);
  return CollaborationClass;


});
define('bpmn/di/DiagramElement',['require', 'exports', 'module', '../util/JSClass', '../Clazz', '../Package'], function (require, exports, module, jsclass, Clazz, Package) {
  

var DiagramElement = {
      tag: "diagramElement",
      initialize: function () {
        this.callSuper();
        this.addAttribute({
          name: "id",
          type: String
        });
        this.addAttribute({
          name: "bpmnElement",
          type: String
        });
      },
      init: function () {
        this._definitions.index.add(this.bpmnElement() + ":di", this);
      }
    };
  var DiagramElementClass = new jsclass.Class(Clazz, DiagramElement);
  Package.registerClass(DiagramElementClass);
  return DiagramElementClass;


});
define('bpmn/di/Bounds',['require', 'exports', 'module', '../util/JSClass', '../Clazz', '../Package'], function (require, exports, module, jsclass, Clazz, Package) {
  

var Bounds = {
      tag: "Bounds",
      initialize: function () {
        this.callSuper();
        this.addAttribute({
          name: "x",
          type: "float"
        });
        this.addAttribute({
          name: "y",
          type: "float"
        });
        this.addAttribute({
          name: "width",
          type: "float"
        });
        this.addAttribute({
          name: "height",
          type: "float"
        });
      },
      init: function () {
        this.callSuper();
      }
    };
  var BoundsClass = new jsclass.Class(Clazz, Bounds);
  Package.registerClass(BoundsClass);
  return BoundsClass;


});
define('bpmn/di/BPMNShape',['require', 'exports', 'module', '../util/JSClass', './DiagramElement', './Bounds', '../Package'], function (require, exports, module, jsclass, DiagramElement, Bounds, Package) {
  

var BPMNShape = {
      tag: "BPMNShape",
      initialize: function () {
        this.callSuper();
        this.addReference({
          name: "bounds",
          type: Bounds
        });
      },
      init: function () {
        this.callSuper();
      }
    };
  var BPMNShapeClass = new jsclass.Class(DiagramElement, BPMNShape);
  Package.registerClass(BPMNShapeClass);
  return BPMNShapeClass;


});
define('bpmn/di/Waypoint',['require', 'exports', 'module', '../util/JSClass', '../Clazz', '../Package'], function (require, exports, module, jsclass, Clazz, Package) {
  

var Waypoint = {
      tag: "waypoint",
      initialize: function () {
        this.callSuper();
        this.addAttribute({
          name: "x",
          type: "float"
        });
        this.addAttribute({
          name: "y",
          type: "float"
        });
      },
      init: function () {
        this.callSuper();
      },
      __internalFieldName: function (field) {
        return field;
      }
    };
  var WaypointClass = new jsclass.Class(Clazz, Waypoint);
  Package.registerClass(WaypointClass);
  return WaypointClass;


});
define('bpmn/di/BPMNEdge',['require', 'exports', 'module', '../util/JSClass', './DiagramElement', './Waypoint', '../Package'], function (require, exports, module, jsclass, DiagramElement, Waypoint, Package) {
  

var BPMNEdge = {
      tag: "BPMNEdge",
      initialize: function () {
        this.callSuper();
        this.addReference({
          name: "waypoints",
          containment: true,
          type: Waypoint
        });
      },
      init: function () {
        this.callSuper();
      }
    };
  var BPMNEdgeClass = new jsclass.Class(DiagramElement, BPMNEdge);
  Package.registerClass(BPMNEdgeClass);
  return BPMNEdgeClass;


});
define('bpmn/di/BPMNPlane',['require', 'exports', 'module', '../util/JSClass', '../Clazz', '../Package', './BPMNShape', './BPMNEdge', './DiagramElement'], function (require, exports, module, jsclass, Clazz, Package, Shape, Edge, DiagramElement) {
  

var BPMNPlane = {
      tag: "BPMNPlane",
      initialize: function () {
        this.callSuper();
        this.addReference({
          name: "diagramElements",
          containment: true,
          type: DiagramElement
        });
      },
      init: function () {
        this.callSuper();
      }
    };
  var BPMNPlaneClass = new jsclass.Class(Clazz, BPMNPlane);
  Package.registerClass(BPMNPlaneClass);
  return BPMNPlaneClass;


});
define('bpmn/di/BPMNDiagram',['require', 'exports', 'module', '../util/JSClass', '../Clazz', './BPMNPlane', '../Package'], function (require, exports, module, jsclass, Clazz, BPMNPlane, Package) {
  

var BPMNDiagram = {
      tag: "BPMNDiagram",
      initialize: function () {
        this.callSuper();
        this.addReference({
          name: "plane",
          type: BPMNPlane
        });
      }
    };
  var BPMNDiagramClass = new jsclass.Class(Clazz, BPMNDiagram);
  Package.registerClass(BPMNDiagramClass);
  return BPMNDiagramClass;


});
define('bpmn/FlowNode',['require', 'exports', 'module', './util/JSClass', './FlowElement', './Package'], function (require, exports, module, jsclass, FlowElement, Package) {
  

var flowNode = {
      tag: "flowNode",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      },
      incoming: function () {
        var incoming = this._definitions.index.item("target:" + this.id());
        return incoming ? incoming : [];
      },
      outgoing: function () {
        var outgoing = this._definitions.index.item("source:" + this.id());
        return outgoing ? outgoing : [];
      }
    };
  var FlowNodeClass = new jsclass.Class(FlowElement, flowNode);
  Package.registerClass(FlowNodeClass);
  return FlowNodeClass;


});
define('bpmn/Event',['require', 'exports', 'module', './util/JSClass', './FlowNode', './Package'], function (require, exports, module, jsclass, FlowNode, Package) {
  

var event = {
      tag: "event",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var EventClass = new jsclass.Class(FlowNode, event);
  Package.registerClass(EventClass);
  return EventClass;


});
define('bpmn/CatchEvent',['require', 'exports', 'module', './util/JSClass', './Event', './Package'], function (require, exports, module, jsclass, Event, Package) {
  

var catchEvent = {
      tag: "catchEvent",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var CatchEventClass = new jsclass.Class(Event, catchEvent);
  Package.registerClass(CatchEventClass);
  return CatchEventClass;


});
define('bpmn/StartEvent',['require', 'exports', 'module', './util/JSClass', './CatchEvent', './Package'], function (require, exports, module, jsclass, CatchEvent, Package) {
  

var startEvent = {
      tag: "startEvent",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var StartEventClass = new jsclass.Class(CatchEvent, startEvent);
  Package.registerClass(StartEventClass);
  return StartEventClass;


});
define('bpmn/ThrowEvent',['require', 'exports', 'module', './util/JSClass', './Event', './Package'], function (require, exports, module, jsclass, Event, Package) {
  

var throwEvent = {
      tag: "throwEvent",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var ThrowEventClass = new jsclass.Class(Event, throwEvent);
  Package.registerClass(ThrowEventClass);
  return ThrowEventClass;


});
define('bpmn/EndEvent',['require', 'exports', 'module', './util/JSClass', './ThrowEvent', './Package'], function (require, exports, module, jsclass, ThrowEvent, Package) {
  

var endEvent = {
      tag: "endEvent",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var EndEventClass = new jsclass.Class(ThrowEvent, endEvent);
  Package.registerClass(EndEventClass);
  return EndEventClass;


});
define('bpmn/BoundaryEvent',['require', 'exports', 'module', './util/JSClass', './CatchEvent', './Package'], function (require, exports, module, jsclass, CatchEvent, Package) {
  

var boundaryEvent = {
      tag: "boundaryEvent",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var BoundaryEventClass = new jsclass.Class(CatchEvent, boundaryEvent);
  Package.registerClass(BoundaryEventClass);
  return BoundaryEventClass;


});
define('bpmn/Activity',['require', 'exports', 'module', './util/JSClass', './FlowNode', './Package'], function (require, exports, module, jsclass, FlowNode, Package) {
  

var activity = {
      tag: "activity",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var ActivityClass = new jsclass.Class(FlowNode, activity);
  Package.registerClass(ActivityClass);
  return ActivityClass;


});
define('bpmn/Task',['require', 'exports', 'module', './util/JSClass', './Activity', './Package'], function (require, exports, module, jsclass, Activity, Package) {
  

var task = {
      tag: "task",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var TaskClass = new jsclass.Class(Activity, task);
  Package.registerClass(TaskClass);
  return TaskClass;


});
define('bpmn/UserTask',['require', 'exports', 'module', './util/JSClass', './Task', './Package'], function (require, exports, module, jsclass, Task, Package) {
  

var userTask = {
      tag: "userTask",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var UserTaskClass = new jsclass.Class(Task, userTask);
  Package.registerClass(UserTaskClass);
  return UserTaskClass;


});
define('bpmn/ServiceTask',['require', 'exports', 'module', './util/JSClass', './Task', './Package'], function (require, exports, module, jsclass, Task, Package) {
  

var serviceTask = {
      tag: "serviceTask",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var ServiceTaskClass = new jsclass.Class(Task, serviceTask);
  Package.registerClass(ServiceTaskClass);
  return ServiceTaskClass;


});
define('bpmn/BusinessRuleTask',['require', 'exports', 'module', './util/JSClass', './Task', './Package'], function (require, exports, module, jsclass, Task, Package) {
  

var businessRuleTask = {
      tag: "businessRuleTask",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var BusinessRuleTaskClass = new jsclass.Class(Task, businessRuleTask);
  Package.registerClass(BusinessRuleTaskClass);
  return BusinessRuleTaskClass;


});
define('bpmn/ReceiveTask',['require', 'exports', 'module', './util/JSClass', './Task', './Package'], function (require, exports, module, jsclass, Task, Package) {
  

var receiveTask = {
      tag: "receiveTask",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var ReceiveTaskClass = new jsclass.Class(Task, receiveTask);
  Package.registerClass(ReceiveTaskClass);
  return ReceiveTaskClass;


});
define('bpmn/SubProcess',['require', 'exports', 'module', './util/JSClass', './Activity', './FlowElementsContainer', './Package'], function (require, exports, module, jsclass, Activity, FlowElementsContainer, Package) {
  

var subProcess = {
      include: [FlowElementsContainer],
      tag: "subProcess",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var SubProcessClass = new jsclass.Class(Activity, subProcess);
  Package.registerClass(SubProcessClass);
  return SubProcessClass;


});
define('bpmn/Gateway',['require', 'exports', 'module', './util/JSClass', './FlowNode', './Package'], function (require, exports, module, jsclass, FlowNode, Package) {
  

var gateway = {
      tag: "gateway",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var GatewayClass = new jsclass.Class(FlowNode, gateway);
  Package.registerClass(GatewayClass);
  return GatewayClass;


});
define('bpmn/ExclusiveGateway',['require', 'exports', 'module', './util/JSClass', './Gateway', './Package'], function (require, exports, module, jsclass, Gateway, Package) {
  

var exclusiveGateway = {
      tag: "exclusiveGateway",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var ExclusiveGateway = new jsclass.Class(Gateway, exclusiveGateway);
  Package.registerClass(ExclusiveGateway);
  return ExclusiveGateway;


});
define('bpmn/ParallelGateway',['require', 'exports', 'module', './util/JSClass', './Gateway', './Package'], function (require, exports, module, jsclass, Gateway, Package) {
  

var parallelGateway = {
      tag: "parallelGateway",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var ParallelGatewayClass = new jsclass.Class(Gateway, parallelGateway);
  Package.registerClass(ParallelGatewayClass);
  return ParallelGatewayClass;


});
define('bpmn/ConditionExpression',['require', 'exports', 'module', './util/JSClass', './BaseElement', './Package'], function (require, exports, module, jsclass, BaseElement, Package) {
  

var conditionExpression = {
      tag: "conditionExpression",
      initialize: function () {
        this.callSuper();
      },
      init: function () {
        this.callSuper();
      }
    };
  var ConditionExpressionClass = new jsclass.Class(BaseElement, conditionExpression);
  Package.registerClass(ConditionExpressionClass);
  return ConditionExpressionClass;


});
define('bpmn/SequenceFlow',['require', 'exports', 'module', './util/JSClass', './FlowElement', './ConditionExpression', './Package'], function (require, exports, module, jsclass, FlowElement, ConditionExpression, Package) {
  

var sequenceFlow = {
      tag: "sequenceFlow",
      initialize: function () {
        this.callSuper();
        this.addAttribute({
          name: "sourceRef",
          type: String
        });
        this.addAttribute({
          name: "targetRef",
          type: String
        });
        this.addReference({
          name: "conditionExpression",
          type: ConditionExpression
        });
      },
      getSourceRef: function () {
        return this._definitions.index.item(this._sourceRef);
      },
      getTargetRef: function () {
        return this._definitions.index.item(this._targetRef);
      },
      init: function () {
        this.callSuper();
        if (!this._definitions.index.addArray) {
          console.log("cant addArray" + this.id());
          console.log(this._definitions.index.tag);
        }
        this._definitions.index.addArray("target:" + this.targetRef(), this);
        this._definitions.index.addArray("source:" + this.sourceRef(), this);
      }
    };
  var SequenceFlowClass = new jsclass.Class(FlowElement, sequenceFlow);
  Package.registerClass(SequenceFlowClass);
  return SequenceFlowClass;


});
define('bpmn/Definitions',['require', 'exports', 'module', './util/JSClass', './util/Index', './BaseElement', './Process', './Collaboration', './di/BPMNDiagram', './StartEvent', './EndEvent', './BoundaryEvent', './UserTask', './ServiceTask', './BusinessRuleTask', './ReceiveTask', './SubProcess', './ExclusiveGateway', './ParallelGateway', './SequenceFlow'], function (require, exports, module, jsclass, Index, BaseElement, Process, Collaboration, BPMNDiagram) {
  

var definitions = {
      tag: "definitions",
      initialize: function () {
        this.callSuper();
        this.addReference({
          name: "collaboration",
          type: Collaboration
        });
        this.addReference({
          name: "process",
          containment: true,
          type: Process
        });
        this.addReference({
          name: "bpmnDiagram",
          type: BPMNDiagram
        });
        this.index = new Index();
      }
    };
  return new jsclass.Class(BaseElement, definitions);


});
define('bpmn/execution/TokenStore',['require', 'exports', 'module', '../util/JSClass'], function (require, exports, module, jsclass) {
  

var tokenStore = {
      initialize: function (tokenMap) {
        this.tokenMap = tokenMap ? tokenMap : {};
      },
      add: function (id, token) {
        if (!this.tokenMap[id]) {
          this.tokenMap[id] = [];
        }
        this.tokenMap[id].push(token);
      },
      drop: function (id, count) {
        if (this.tokenMap[id]) {
          for (var c = 0; c < count; c++) {
            this.tokenMap[id].pop();
          }
        }
      },
      query: function (id) {
        return this.tokenMap[id] ? this.tokenMap[id] : [];
      },
      count: function () {
        var result = 0;
        for (var key in this.tokenMap) {
          result += this.tokenMap[key].length;
        }
        return result;
      }
    };
  return new jsclass.Class(tokenStore);


});
define('lodash',[],function () {
  if (__isNode) {
  return __nodeRequire('lodash');
} else {
  return (typeof _ !== 'undefined') ? _ : __nodeRequire('lodash')
}
});
define('jquery',[],function () {
  if (__isNode) {
  return __nodeRequire('jquery');
} else {
  return (typeof $ !== 'undefined') ? $ : __nodeRequire('jquery')
}
});
define('bpmn/util/Topic',['require', 'exports', 'module', './JSClass'], function (require, exports, module, jsclass) {
  

var topic = {
      publish: function (eventPath, message) {
      }
    };
  return new jsclass.Class(topic);


});
define('bpmn/execution/Instance',['require', 'exports', 'module', './TokenStore', '../util/JSClass', 'lodash', 'jquery', '../util/Topic'], function (require, exports, module, TokenStore, jsclass, _, $, Topic) {
  

var instance = {
      initialize: function (definitions, configuration, tokenMap, variables) {
        this.definitions = definitions;
        this.configuration = configuration;
        this.tokenStore = new TokenStore(tokenMap);
        this.variables = variables ? variables : {};
        this.topic = new Topic();
        this.behaviours["startEvent"] = this.behaviours["takeAll"];
        this.behaviours["endEvent"] = this.behaviours["takeNone"];
        this.behaviours["userTask"] = this.behaviours["takeNone"];
        this.behaviours["serviceTask"] = this.behaviours["takeAll"];
        this.behaviours["exclusiveGateway"] = this.behaviours["xor"];
        this.behaviours["parallelGateway"] = this.behaviours["and"];
      },
      behaviours: {
        "takeAll": function (element) {
          this.dropToken(element.id(), this.tokenStore);
          return element.outgoing();
        },
        "takeNone": function (element) {
          return [];
        },
        "xor": function (element) {
          this.dropToken(element.id(), this.tokenStore);
          if (element.outgoing().length == 1) {
            return element.outgoing();
          }
          var transition = null;
          _.map(element.outgoing(), function (outgoing) {
            var flowConfig = this.configuration[outgoing.id()];
            if (!transition && flowConfig && flowConfig(this)) {
              transition = outgoing;
            }
          }, this);
          if (!transition && !element.getDefault()) {
            throw new Error("No transition evaluated to true and no default defined");
          }
          return transition;
        },
        "and": function (element) {
          var isActive = true;
          var tokens = this.tokenStore.query(element.id());
          var fromMap = {};
          if (element.incoming().length == 1) {
            return _.bind(this.behaviours.takeAll, this)(element);
          }
          for (var index = 0; index < tokens.length; index++) {
            var token = tokens[index];
            fromMap[token.from] = token;
          }
          var activeTransitions = [];
          _.map(element.incoming(), function (incoming) {
            if (!fromMap[incoming.id()]) {
              isActive = false;
            } else {
              activeTransitions.push(incoming);
            }
          }, this);
          if (isActive) {
            _.map(activeTransitions, function (t) {
              _.bind(this.dropToken, this)(t.sourceRef(), this.tokenStore);
            }, this);
            return _.bind(this.behaviours.takeAll, this)(element);
          } else {
            return [];
          }
        }
      },
      dropToken: function (id, tokenStore, count) {
        if (tokenStore.query(id).length > 0) {
          tokenStore.drop(id, count ? count : 1);
        }
      },
      copyVariables: function (variables) {
        if (variables) {
          for (var index in variables) {
            this.variables[index] = variables[index];
          }
        }
      },
      start: function (startId, variables) {
        this.tokenStore.add(startId, { from: null });
        return this.trigger(startId, variables);
      },
      trigger: function (elementId, variables, behaviour, path) {
        console.log("trigger", elementId);
        var deferred = $.Deferred();
        var path = path ? path : $.Deferred();
        this.copyVariables(variables);
        var node = this.definitions.index.item(elementId);
        var nodeBehaviour = behaviour ? this.behaviours[behaviour] : this.behaviours[node.tag];
        console.log("nodeBehaviour", nodeBehaviour);
        var transitions = [].concat(_.bind(nodeBehaviour, this)(node, this.tokenStore));
        console.log("next", transitions);
        if (transitions.length > 0 && this.configuration.leave) {
          this.configuration.leave(node);
          this.topic.publish("flow:leave:" + node.id(), node);
        }
        if (transitions.length == 0) {
          path.resolve();
        }
        transitions.map(function (transition) {
          this.tokenStore.add(transition.targetRef(), { from: transition.id() });
          var pubPath = "flow:enter:" + transition.targetRef();
          this.topic.publish(pubPath, transition.getTargetRef());
          if (this.configuration.enter) {
            this.configuration.enter(transition.getTargetRef());
          }
          var self = this;
          deferred.then(function () {
            console.log("then for", transition.id());
            self.trigger(transition.targetRef(), null, null, path);
          });
        }, this);
        if (this.configuration[elementId] && this.configuration[elementId]) {
          this.configuration[elementId]({
            instance: this,
            promise: deferred
          });
        } else {
          console.log("resolving", elementId, this.tokenStore.tokenMap);
          deferred.resolve();
        }
        return path;
      }
    };
  return new jsclass.Class(instance);


});
define('sax',[],function () {
  if (__isNode) {
  return __nodeRequire('sax');
} else {
  return (typeof sax !== 'undefined') ? sax : __nodeRequire('sax')
}
});
define('bpmn/util/Serializer',['require', 'exports', 'module', './JSClass', '../Package', '../Definitions', '../BaseElement', 'sax'], function (require, exports, module, jsclass, Package, Definitions, BaseElement) {
  

var serializer = {
      initialize: function () {
      },
      fromXML: function (xmlString) {
        if (!xmlString) {
          return;
        }
        var setAttributeFromNode = function (attrName, node, bpmnObj, type) {
          if (node.attributes[attrName]) {
            var value = node.attributes[attrName].value;
            if (type == "float") {
              value = parseFloat(value);
            }
            if (type == "boolean") {
              value = value.toLowerCase() == "true";
            }
            if (type == "integer") {
              value = parseInt(value);
            }
            bpmnObj[attrName](value);
          }
        };
        var parser = sax.parser(true, {
            xmlns: true,
            lowercase: true,
            trim: true
          });
        parser.stack = [];
        Array.prototype.peek = function () {
          return this.length == 0 ? null : this[this.length - 1];
        };
        var openTagHandlers = {
            "definitions": function (node) {
              parser.definitions = new Definitions();
              parser.stack.push(parser.definitions);
            },
            "default": function (node) {
              var parent = parser.stack.peek();
              var tagLookup = node.local.toLowerCase();
              var PackageClass = Package.tagMap[tagLookup];
              var newRef = PackageClass ? new PackageClass() : new BaseElement();
              parser.stack.push(newRef);
              newRef._definitions = parser.definitions;
              for (var attributeName in newRef.attribute) {
                setAttributeFromNode(attributeName, node, newRef, newRef.attribute[attributeName].type);
              }
              var refFound = null;
              for (var index in parent.reference) {
                var ref = parent.reference[index];
                if (newRef.isA(ref.type)) {
                  refFound = ref;
                  break;
                }
              }
              newRef.init();
              if (refFound && refFound.containment === true) {
                parent[refFound.name]().push(newRef);
              } else if (refFound) {
                parent[refFound.name](newRef);
              }
            }
          };
        parser.onerror = function (e) {
          console.log("error", e);
        };
        parser.onopentag = function (node) {
          if (openTagHandlers[node.local]) {
            openTagHandlers[node.local](node);
          } else {
            openTagHandlers["default"](node);
          }
        };
        parser.onclosetag = function (node) {
          parser.stack.pop();
        };
        parser.ontext = function (t) {
          parser.stack.peek().setText(t);
        };
        parser.onend = function () {
        };
        parser.write(xmlString).close();
        return parser.definitions;
      }
    };
  return new jsclass.Class(serializer);


});
define('fabric',[],function () {
  if (__isNode) {
  return __nodeRequire('fabric');
} else {
  return (typeof fabric !== 'undefined') ? fabric : __nodeRequire('fabric')
}
});
define('bpmn/util/diagram/Canvas',['require', 'exports', 'module', 'fabric', 'lodash'], function (require, exports, module, fabric, _) {
  

var Canvas = function Canvas(options) {
    this.scale = options.scale;
    var canvas = this.canvas = new fabric.Canvas(options.container);
    var shapeGroup = this.shapeGroup = new fabric.Group([], {
        left: 0,
        top: 0
      }).setOriginX(0).setOriginY(0);
    shapeGroup.setScaleX(this.scale);
    shapeGroup.setScaleY(this.scale);
    canvas.add(shapeGroup);
    var connectionGroup = this.connectionGroup = new fabric.Group([], {}).setOriginX(0).setOriginY(0);
    connectionGroup.setScaleX(this.scale);
    connectionGroup.setScaleY(this.scale);
    canvas.add(connectionGroup);
    this.draw = function () {
      this.canvas.renderAll();
    };
    this.addShape = function (shape) {
      shapeGroup.add(shape);
    };
    this.addConnection = function (connection) {
      connectionGroup.add(connection);
    };
    this.createGroup = function (groupOptions) {
      return new fabric.Group([], {
        top: 0,
        left: 0,
        width: 0,
        height: 0
      }).setOriginX(0).setOriginY(0);
    };
    this.createRect = function (rect) {
      return new fabric.Rect({
        left: rect.left,
        top: rect.top,
        width: rect.width,
        height: rect.height,
        fill: rect.fill,
        stroke: rect.stroke,
        strokeWidth: rect.strokeWidth,
        padding: 0,
        rx: rect.cornerRadius,
        ry: rect.cornerRadius
      });
    };
    this.createCircle = function (circle) {
      return new fabric.Circle({
        radius: circle.width / 2 - circle.strokeWidth,
        left: 0,
        top: 0,
        fill: circle.fill,
        stroke: circle.stroke,
        strokeWidth: circle.strokeWidth
      });
    };
    this.createText = function (text) {
      var textProperties = {
          top: text.top,
          left: text.left,
          width: text.width,
          height: text.height,
          fontSize: text.fontSize,
          fontFamily: text.fontFamily
        };
      var textObj = new fabric.Text(text.text, textProperties);
      return textObj;
    };
    this.createPolygon = function (polygon) {
      var polygonProperties = {
          top: 0,
          left: 0,
          fill: polygon.fill,
          stroke: polygon.stroke,
          strokeWidth: polygon.strokeWidth
        };
      return new fabric.Polygon(polygon.points, polygonProperties);
    };
    this.createPath = function (pathProperties) {
      var path = new fabric.Path(pathProperties.data);
      path.set({
        left: 0,
        top: 0
      });
      return path;
    };
    this.createArrowLine = function (points, lineOptions, size) {
      var arrowSize = size ? size : 8;
      var last = points[points.length - 1];
      var secondLast = points[points.length - 2];
      var angle = Math.atan2(last.y - secondLast.y, last.x - secondLast.x);
      var firstArrowPoint = {
          x: last.x - arrowSize * Math.cos(angle - Math.PI / 6),
          y: last.y - arrowSize * Math.sin(angle - Math.PI / 6)
        };
      var arrowPoints = [
          firstArrowPoint,
          {
            x: last.x,
            y: last.y
          },
          {
            x: last.x - arrowSize * Math.cos(angle + Math.PI / 6),
            y: last.y - arrowSize * Math.sin(angle + Math.PI / 6)
          }
        ];
      var linePoints = points.concat(arrowPoints);
      var lineGroup = new fabric.Group([], {});
      var previous = null;
      _.forEach(linePoints, function (point, index) {
        if (index == 0) {
          previous = point;
          return;
        }
        var line = new fabric.Line([
            previous.x,
            previous.y,
            point.x,
            point.y
          ], {
            stroke: lineOptions.stroke,
            fill: "white",
            strokeWidth: lineOptions.strokeWidth
          });
        lineGroup.add(line);
        previous = point;
      });
      return lineGroup;
    };
    this.expandCanvasIfNeeded = function (shape) {
      var buffer = 10;
      var x = shape.getLeft(), y = shape.getTop(), width = shape.getWidth(), height = shape.getHeight();
      if ((x + width) * this.scale > this.canvas.getWidth()) {
        this.canvas.setWidth((x + width + buffer) * this.scale);
      }
      if ((y + height) * this.scale > this.canvas.getHeight()) {
        this.canvas.setHeight((y + height + buffer) * this.scale);
      }
      this.canvas.calcOffset();
    };
  };
  return Canvas;


});
define('bpmn/editor/ActivityRenderer',['require','exports','module'],function (require, exports, module) {
  

var ActivityRenderer = function (renderer) {
    this.markerPaths = {
      "serviceTask": "m 14.867748,9.688475 c 0.280053,0 0.540605,-0.235339 0.578706,-0.522905 0,0 0.05355,-0.404146 0.05355,-0.884769 0,-0.480624 -0.05355,-0.884771 -0.05355,-0.884771 -0.03823,-0.28772 -0.298653,-0.522904 -0.578706,-0.522904 h -1.447215 c -0.280203,0 -0.571206,-0.18513 -0.646506,-0.411297 -0.0753,-0.226167 -0.178952,-0.951766 0.0192,-1.156948 l 1.023009,-1.060108 c 0.198001,-0.205338 0.213301,-0.555702 0.0339,-0.77876 L 12.646525,2.218443 C 12.431273,2.032379 12.093319,2.048234 11.895017,2.253573 L 10.872008,3.313681 C 10.674005,3.519021 10.343852,3.601716 10.138799,3.49757 9.9335984,3.393425 9.3586419,2.954148 9.3586419,2.663784 V 1.1640891 c 0,-0.29036388 -0.227102,-0.56020928 -0.5046052,-0.59984728 0,0 -0.3900032,-0.055653 -0.8538078,-0.055653 -0.463806,0 -0.8538092,0.055653 -0.8538092,0.055653 C 6.868767,0.60372312 6.6416649,0.87372522 6.6416649,1.1640891 V 2.663784 c 0,0.290364 -0.1785017,0.591765 -0.3969041,0.669951 C 6.0263585,3.411765 5.3263015,3.519177 5.1281493,3.313845 L 4.1051389,2.253728 C 3.9069868,2.04839 3.5688835,2.032535 3.3537816,2.218442 L 2.1500193,3.465857 c -0.179552,0.223058 -0.1642519,0.573422 0.033898,0.77876 L 3.2067775,5.304725 C 3.4049297,5.510063 3.4848802,5.852033 3.3842297,6.064521 3.2835793,6.277009 2.8598246,6.87297 2.5796218,6.87297 H 1.1325571 c -0.2802027,0 -0.54060564,0.235339 -0.57885593,0.522904 0,0 -0.0537012,0.404147 -0.0537012,0.88477 0,0.480779 0.0537012,0.88477 0.0537012,0.88477 0.0380982,0.287721 0.29865323,0.522904 0.57885593,0.522904 h 1.4472148 c 0.2802028,0 0.5710558,0.184976 0.6463564,0.411299 0.075301,0.226165 0.1789517,0.951609 -0.019201,1.156947 L 2.184067,12.316517 c -0.1981522,0.205337 -0.2134522,0.555702 -0.033898,0.77876 l 1.2036123,1.24757 c 0.2152519,0.185908 0.5532051,0.170209 0.7513572,-0.03514 l 1.0230111,-1.060103 c 0.1981514,-0.205185 0.5281549,-0.288035 0.7333572,-0.183889 0.2052015,0.104146 0.7801577,0.543423 0.7801577,0.833786 V 15.3972 c 0,0.29021 0.2271024,0.56021 0.5047551,0.599692 0,0 0.3898537,0.05549 0.8538092,0.05549 0.4639541,0 0.8538078,-0.05549 0.8538078,-0.05549 0.2776533,-0.03963 0.5046052,-0.309482 0.5046052,-0.599691 v -1.499692 c 0,-0.290364 0.1785024,-0.59192 0.3969045,-0.669951 0.2184021,-0.07803 0.9184587,-0.185287 1.1166107,0.01989 l 1.022859,1.060109 c 0.198152,0.205183 0.536256,0.221037 0.751509,0.03514 l 1.203613,-1.247104 c 0.179402,-0.223059 0.164251,-0.573266 -0.03405,-0.778759 l -1.022859,-1.059949 c -0.198153,-0.205337 -0.278104,-0.547307 -0.177453,-0.75995 0.100501,-0.212644 0.524406,-0.80845 0.804608,-0.80845 h 1.447365 z m -6.8676686,1.437052 c -1.5162163,0 -2.7453284,-1.273528 -2.7453284,-2.844882 0,-1.571043 1.2291121,-2.844882 2.7453284,-2.844882 1.5162152,0 2.7453276,1.273683 2.7453276,2.844882 0,1.571198 -1.2291124,2.844882 -2.7453276,2.844882 z",
      "userTask": "M 7.6955681,7.542161 C 7.3167492,6.843663 6.852991,6.278031 6.3879925,5.882595 5.8454944,6.288155 5.1845767,6.534907 4.4641391,6.534907 3.7424616,6.534907 3.0809239,6.287522 2.5390458,5.882595 2.0740474,6.278031 1.610289,6.843663 1.2302303,7.542161 0.34859343,9.163766 0.25187377,10.827129 1.0132311,11.258629 c 0.3409988,0.194238 0.6987376,0.04935 1.0682563,-0.313818 -0.0651,0.36823 -0.1029196,0.767462 -0.1029196,1.185042 0,1.85507 0.7061775,3.357728 1.5766545,3.357728 0.5245182,0 0.7842973,-0.547284 0.9089168,-1.384976 0.1246196,0.837692 0.3843987,1.384976 0.9070569,1.384976 0.8717169,0 1.5778946,-1.502658 1.5778946,-3.357728 0,-0.41758 -0.037821,-0.816812 -0.1041598,-1.185042 0.3707588,0.363168 0.7278777,0.508056 1.0694965,0.313818 0.761357,-0.4315 0.6627773,-2.094863 -0.2188592,-3.716468 z M 4.4635192,5.902209 c 1.4644349,0 2.652351,-1.212249 2.652351,-2.707314 0,-1.495065 -1.1879161,-2.70731418 -2.652351,-2.70731418 -1.4650549,0 -2.6535908,1.21224918 -2.6535908,2.70731418 0,1.495065 1.1885359,2.707314 2.6535908,2.707314 z",
      "businessRuleTask": "m -6.6775,-6.4391075 v 1.7073217 H 6.3224105 V -6.4391075 H -6.6775 z m 0,9.2357054 H 6.3224105 V 1.0892767 H -6.6775 v 1.7073212 z m 0,-3.76419196 H 6.3224105 V -2.6749155 H -6.6775 v 1.70732144 z m 0,7.52781506 H 6.3224105 V 4.8528994 H -6.6775 V 6.560221 z",
      "receiveTask": "m 6.612092,-4.0112852 -12.2876956,0.048953 -1.1259638,0 0.8811885,0.7098496 3.2310263,2.54565661 L -6.2385858,-3.3748709 -6.875,-3.839943 l 0,0.7832793 0,8.6650229 L -6.875,6 -6.4833605,6 7.395362,6 7.787,6 l 0,-0.3916408 0,-8.6650229 0,-0.7832793 -0.636423,0.4650721 -3.891903,2.93729731 3.598184,-2.86386481 0.881186,-0.7098468 -1.125952,0 z M 5.510602,-3.228006 0.44376231,0.78629811 -4.54964,-3.1790514 5.510602,-3.2280057 z m -11.6023227,0.9546218 6.31518591,4.7241513 0.2447763,0.1713424 0.220297,-0.1713424 6.31519149,-4.7241513 0,7.4901076 -13.0954507,0 0,-7.4901076 z"
    };
    this.createRectangle = function (bounds) {
      var cornerRadius = renderer.skin()["activity_corner_radius"];
      return renderer.canvas.createRect({
        left: 0,
        top: 0,
        width: bounds.width(),
        height: bounds.height(),
        cornerRadius: cornerRadius,
        stroke: renderer.skin()["activity_stroke"],
        fill: renderer.skin()["activity_fill"],
        strokeWidth: 2
      });
    };
    this.getPathForActivityType = function (activity) {
      return this.markerPaths[activity.tag];
    };
    this.createMarker = function (pathForType) {
      var activityMarker = renderer.canvas.createPath({
          x: 0,
          y: 0,
          data: pathForType,
          stroke: renderer.skin()["activity_stroke"],
          fill: renderer.skin()["activity_fill"]
        });
      return activityMarker;
    };
    this.render = function (activity, group) {
      var bounds = activity.getBounds();
      var rect = this.createRectangle(bounds);
      group.add(rect);
      var pathForType = this.getPathForActivityType(activity);
      if (pathForType) {
        var activityMarker = this.createMarker(pathForType);
        group.add(activityMarker);
      }
      return group;
    };
  };
  return ActivityRenderer;


});
define('bpmn/editor/EventRenderer',['require', 'exports', 'module', 'lodash', '../EndEvent'], function (require, exports, module, _, EndEvent) {
  

var EventRenderer = function (renderer) {
    this.typeProperties = function (event) {
      if (event instanceof EndEvent) {
        return { strokeWidth: 4 };
      }
      return {};
    };
    this.render = function (event, group) {
      var bounds = event.getBounds();
      var eventProperties = {
          left: 0,
          top: 0,
          width: bounds.width(),
          height: bounds.height(),
          fill: renderer.skin()["event_fill"],
          stroke: renderer.skin()["event_stroke"],
          strokeWidth: 2
        };
      _.extend(eventProperties, this.typeProperties(event));
      var circle = renderer.canvas.createCircle(eventProperties);
      group.add(circle);
      return group;
    };
  };
  return EventRenderer;


});
define('bpmn/editor/GatewayRenderer',['require','exports','module'],function (require, exports, module) {
  

var GatewayRenderer = function (renderer) {
    this.render = function (gateway, group) {
      var bounds = gateway.getBounds();
      var rect = renderer.canvas.createPolygon({
          points: [
            {
              x: 0,
              y: bounds.height() / 2
            },
            {
              x: bounds.width() / 2,
              y: 0
            },
            {
              x: bounds.width(),
              y: bounds.height() / 2
            },
            {
              x: bounds.width() / 2,
              y: bounds.height()
            }
          ],
          stroke: renderer.skin()["gateway_stroke"],
          fill: renderer.skin()["gateway_fill"],
          strokeWidth: 2,
          draggable: true
        });
      group.add(rect);
      return group;
    };
  };
  return GatewayRenderer;


});
define('bpmn/editor/LabelRenderer',['require','exports','module'],function (require, exports, module) {
  

var Label = function (renderer) {
    this.renderCentered = function (bounds, group, labelText) {
      var text = this.createLabelText(labelText, bounds);
      var updatedProperties = {
          top: bounds.height() / 2 - text.getFontSize() / 2,
          left: bounds.width() / 2 - text.getWidth() / 2
        };
      text.set(updatedProperties).setCoords();
      group.add(text);
      return group;
    };
    this.createLabelText = function (text, bounds) {
      return renderer.canvas.createText({
        text: text.replace(/\\n/g, "\n"),
        width: bounds.width(),
        height: bounds.height(),
        fontSize: renderer.skin()["label_font_size"],
        fontFamily: renderer.skin()["label_font_family"],
        fill: renderer.skin()["label_fill"]
      });
    };
  };
  return Label;


});
define('bpmn/editor/Renderer',['require', 'exports', 'module', '../util/JSClass', 'lodash', '../Activity', '../Gateway', '../Event', '../SequenceFlow', '../util/diagram/Canvas', './ActivityRenderer', './EventRenderer', './GatewayRenderer', './LabelRenderer'], function (require, exports, module, jsclass, _, Activity, Gateway, Event, SequenceFlow, Canvas, ActivityRenderer, EventRenderer, GatewayRenderer, LabelRenderer) {
  

var Renderer = {
      skins: {
        "default": {
          "sequence_flow_stroke": "black",
          "event_stroke": "black",
          "event_fill": "white",
          "activity_stroke": "black",
          "activity_fill": "white",
          "activity_corner_radius": 10,
          "gateway_stroke": "black",
          "gateway_fill": "white",
          "label_font_family": "Arial",
          "label_font_size": 12,
          "label_fill": "black"
        }
      },
      initialize: function (definitions, options) {
        this.definitions = definitions;
        this.skinName = "default";
        this.bindDelegates();
        this.evaluateOptionsAndDefaults(options);
        this.canvas = new Canvas(this.options);
      },
      bindDelegates: function () {
        this.activity = new ActivityRenderer(this);
        this.event = new EventRenderer(this);
        this.gateway = new GatewayRenderer(this);
        this.label = new LabelRenderer(this);
      },
      evaluateOptionsAndDefaults: function (options) {
        this.options = options;
        this.skinName = options.skin ? options.skin : "default";
        this.options.scale = options.scale ? options.scale : 1;
      },
      render: function () {
        this.renderElements();
        this.canvas.draw();
      },
      renderElements: function () {
        if (this.definitions.process().length > 1) {
          throw new Error("Only single process models are supported");
        }
        _.forEach(this.definitions.process(), function (process) {
          _.forEach(process.flowElements(), function (flowElement) {
            this.renderElement(flowElement);
          }, this);
        }, this);
      },
      renderElement: function (element) {
        var group = this.canvas.createGroup({ draggable: true });
        if (element instanceof SequenceFlow) {
          this.renderConnection(element, group);
          this.canvas.addConnection(group);
        } else if (element instanceof Activity) {
          var activityGroup = this.activity.render(element, group);
          this.label.renderCentered(element.getBounds(), activityGroup, element.name());
          this.canvas.addShape(group);
          this.setGroupBounds(group, element.getBounds());
        } else if (element instanceof Event) {
          this.event.render(element, group);
          this.canvas.addShape(group);
          this.setGroupBounds(group, this.eventBounds(element));
        } else if (element instanceof Gateway) {
          this.gateway.render(element, group);
          this.canvas.addShape(group);
          this.setGroupBounds(group, element.getBounds());
        } else {
          console.log("unable to render flowElement", element);
        }
        this.canvas.expandCanvasIfNeeded(group);
      },
      eventBounds: function (eventElement) {
        var bounds = eventElement.getBounds();
        return {
          x: function () {
            return bounds.x();
          },
          y: function () {
            return bounds.y();
          },
          width: function () {
            return bounds.width();
          },
          height: function () {
            return bounds.height();
          }
        };
      },
      setGroupBounds: function (group, bounds, offset) {
        var offset = offset ? offset : 0;
        var coords = {
            left: bounds.x() + offset,
            top: bounds.y() + offset,
            width: bounds.width(),
            height: bounds.height()
          };
        group.set(coords).setCoords();
      },
      renderConnection: function (connection, group) {
        var arrow = this.canvas.createArrowLine(connection.getWaypoints(), {
            stroke: this.skin()["sequence_flow_stroke"],
            strokeWidth: 2,
            lineCap: "round",
            lineJoin: "round"
          });
        group.add(arrow);
        return group;
      },
      skin: function () {
        return this.skins[this.skinName];
      }
    };
  return new jsclass.Class(Renderer);


});
define('bpmn/Bpmn',['require', 'exports', 'module', './util/JSClass', './Definitions', './execution/Instance', './util/Serializer', './editor/Renderer'], function (require, exports, module, jsclass, Definitions, Instance, Serializer, Renderer) {
  

var bpmn = {
      initialize: function () {
        this.serializer = new Serializer();
      },
      fromXML: function (bpmnXml) {
        return this.serializer.fromXML(bpmnXml);
      },
      renderer: function (definitions, options) {
        return new Renderer(definitions, options);
      },
      instance: function (definitions, configuration) {
        return new Instance(definitions, configuration);
      }
    };
  var bpmnClass = new jsclass.Class(bpmn);
  window.Bpmn = bpmnClass;
  return bpmnClass;


});
    return require('bpmn/Bpmn');
  };
if (__isAMD) {
  return define(['sax', 'jquery', 'lodash', 'fabric'], bundleFactory);
} else {
    if (__isNode) {
        return module.exports = bundleFactory(require('sax'), require('jquery'), require('lodash'), require('fabric'));
    } else {
        return bundleFactory((typeof sax !== 'undefined') ? sax : void 0, (typeof $ !== 'undefined') ? $ : void 0, (typeof _ !== 'undefined') ? _ : void 0, (typeof fabric !== 'undefined') ? fabric : void 0);
    }
}
}).call(this, (typeof exports === 'object' ? global : window),
              (typeof exports === 'object' ? global : window))