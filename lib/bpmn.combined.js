// Generated by uRequire v0.7.0-beta.14 target: 'combined' template: 'combined'
// Combined template optimized with RequireJS/r.js v2.1.15 & almond v0.3.0.
(function (global, window){
  
var __isAMD = !!(typeof define === 'function' && define.amd),
    __isNode = (typeof exports === 'object'),
    __isWeb = !__isNode;


  var __nodeRequire = (__isNode ? require : function(dep){
        throw new Error("uRequire: combined template 'combined', trying to load `node` dep `" + dep + "` in non-nodejs runtime (browser).")
      }),
      __throwMissing = function(dep, vars) {
        throw new Error("uRequire: combined template 'combined', detected missing dependency `" + dep + "` - all it's known binding variables `" + vars + "` were undefined")
      },
      __throwExcluded = function(dep, descr) {
        throw new Error("uRequire: combined template 'combined', trying to access unbound / excluded `" + descr + "` dependency `" + dep + "` on browser");
      };
var bundleFactory = function(_, Q, sax, $) {
/**
 * @license almond 0.3.0 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                name = baseParts.concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("almond", function(){});

define('bpmn/util/JSClass',['require', 'exports', 'module'], function (require, exports, module) {
  

var JS = typeof this.JS === "undefined" ? {} : this.JS;
(function (factory) {
  var $ = typeof this.global === "object" ? this.global : this, E = typeof exports === "object";
  if (E) {
    exports.JS = exports;
    JS = exports;
  } else {
    $.JS = JS;
  }
  factory($, JS);
}(function (global, exports) {
  "use strict";
  var JS = { ENV: global };
  JS.END_WITHOUT_DOT = /([^\.])$/;
  JS.array = function (enumerable) {
    var array = [], i = enumerable.length;
    while (i--)
      array[i] = enumerable[i];
    return array;
  };
  JS.bind = function (method, object) {
    return function () {
      return method.apply(object, arguments);
    };
  };
  JS.Date = JS.ENV.Date;
  JS.extend = function (destination, source, overwrite) {
    if (!destination || !source)
      return destination;
    for (var field in source) {
      if (destination[field] === source[field])
        continue;
      if (overwrite === false && destination.hasOwnProperty(field))
        continue;
      destination[field] = source[field];
    }
    return destination;
  };
  JS.indexOf = function (list, item) {
    if (list.indexOf)
      return list.indexOf(item);
    var i = list.length;
    while (i--) {
      if (list[i] === item)
        return i;
    }
    return -1;
  };
  JS.isType = function (object, type) {
    if (typeof type === "string")
      return typeof object === type;
    if (object === null || object === undefined)
      return false;
    return typeof type === "function" && object instanceof type || object.isA && object.isA(type) || object.constructor === type;
  };
  JS.makeBridge = function (parent) {
    var bridge = function () {
    };
    bridge.prototype = parent.prototype;
    return new bridge();
  };
  JS.makeClass = function (parent) {
    parent = parent || Object;
    var constructor = function () {
      return this.initialize ? this.initialize.apply(this, arguments) || this : this;
    };
    constructor.prototype = JS.makeBridge(parent);
    constructor.superclass = parent;
    constructor.subclasses = [];
    if (parent.subclasses)
      parent.subclasses.push(constructor);
    return constructor;
  };
  JS.match = function (category, object) {
    if (object === undefined)
      return false;
    return typeof category.test === "function" ? category.test(object) : category.match(object);
  };
  JS.Method = JS.makeClass();
  JS.extend(JS.Method.prototype, {
    initialize: function (module, name, callable) {
      this.module = module;
      this.name = name;
      this.callable = callable;
      this._words = {};
      if (typeof callable !== "function")
        return;
      this.arity = callable.length;
      var matches = callable.toString().match(/\b[a-z\_\$][a-z0-9\_\$]*\b/gi), i = matches.length;
      while (i--)
        this._words[matches[i]] = true;
    },
    setName: function (name) {
      this.callable.displayName = this.displayName = name;
    },
    contains: function (word) {
      return this._words.hasOwnProperty(word);
    },
    call: function () {
      return this.callable.call.apply(this.callable, arguments);
    },
    apply: function (receiver, args) {
      return this.callable.apply(receiver, args);
    },
    compile: function (environment) {
      var method = this, trace = method.module.__trace__ || environment.__trace__, callable = method.callable, words = method._words, allWords = JS.Method._keywords, i = allWords.length, keywords = [], keyword;
      while (i--) {
        keyword = allWords[i];
        if (words[keyword.name])
          keywords.push(keyword);
      }
      if (keywords.length === 0 && !trace)
        return callable;
      var compiled = function () {
        var N = keywords.length, j = N, previous = {}, keyword, existing, kwd;
        while (j--) {
          keyword = keywords[j];
          existing = this[keyword.name];
          if (existing && !existing.__kwd__)
            continue;
          previous[keyword.name] = {
            _value: existing,
            _own: this.hasOwnProperty(keyword.name)
          };
          kwd = keyword.filter(method, environment, this, arguments);
          if (kwd)
            kwd.__kwd__ = true;
          this[keyword.name] = kwd;
        }
        var returnValue = callable.apply(this, arguments), j = N;
        while (j--) {
          keyword = keywords[j];
          if (!previous[keyword.name])
            continue;
          if (previous[keyword.name]._own)
            this[keyword.name] = previous[keyword.name]._value;
          else
            delete this[keyword.name];
        }
        return returnValue;
      };
      return compiled;
    },
    toString: function () {
      var name = this.displayName || this.module.toString() + "#" + this.name;
      return "#<Method:" + name + ">";
    }
  });
  JS.Method.create = function (module, name, callable) {
    if (callable && callable.__inc__ && callable.__fns__)
      return callable;
    var method = typeof callable !== "function" ? callable : new this(module, name, callable);
    this.notify(method);
    return method;
  };
  JS.Method.compile = function (method, environment) {
    return method instanceof this ? method.compile(environment) : method;
  };
  JS.Method.__listeners__ = [];
  JS.Method.added = function (block, context) {
    this.__listeners__.push([
      block,
      context
    ]);
  };
  JS.Method.notify = function (method) {
    var listeners = this.__listeners__, i = listeners.length, listener;
    while (i--) {
      listener = listeners[i];
      listener[0].call(listener[1], method);
    }
  };
  JS.Method._keywords = [];
  JS.Method.keyword = function (name, filter) {
    this._keywords.push({
      name: name,
      filter: filter
    });
  };
  JS.Method.trace = function (classes) {
    var i = classes.length;
    while (i--) {
      classes[i].__trace__ = true;
      classes[i].resolve();
    }
  };
  JS.Method.untrace = function (classes) {
    var i = classes.length;
    while (i--) {
      classes[i].__trace__ = false;
      classes[i].resolve();
    }
  };
  JS.Module = JS.makeClass();
  JS.Module.__queue__ = [];
  JS.extend(JS.Module.prototype, {
    initialize: function (name, methods, options) {
      if (typeof name !== "string") {
        options = arguments[1];
        methods = arguments[0];
        name = undefined;
      }
      options = options || {};
      this.__inc__ = [];
      this.__dep__ = [];
      this.__fns__ = {};
      this.__tgt__ = options._target;
      this.__anc__ = null;
      this.__mct__ = {};
      this.setName(name);
      this.include(methods, { _resolve: false });
      if (JS.Module.__queue__)
        JS.Module.__queue__.push(this);
    },
    setName: function (name) {
      this.displayName = name || "";
      for (var field in this.__fns__)
        this.__name__(field);
      if (name && this.__meta__)
        this.__meta__.setName(name + ".");
    },
    __name__: function (name) {
      if (!this.displayName)
        return;
      var object = this.__fns__[name];
      if (!object)
        return;
      name = this.displayName.replace(JS.END_WITHOUT_DOT, "$1#") + name;
      if (typeof object.setName === "function")
        return object.setName(name);
      if (typeof object === "function")
        object.displayName = name;
    },
    define: function (name, callable, options) {
      var method = JS.Method.create(this, name, callable), resolve = (options || {})._resolve;
      this.__fns__[name] = method;
      this.__name__(name);
      if (resolve !== false)
        this.resolve();
    },
    include: function (module, options) {
      if (!module)
        return this;
      var options = options || {}, resolve = options._resolve !== false, extend = module.extend, include = module.include, extended, field, value, mixins, i, n;
      if (module.__fns__ && module.__inc__) {
        this.__inc__.push(module);
        if ((module.__dep__ || {}).push)
          module.__dep__.push(this);
        if (extended = options._extended) {
          if (typeof module.extended === "function")
            module.extended(extended);
        } else {
          if (typeof module.included === "function")
            module.included(this);
        }
      } else {
        if (this.shouldIgnore("extend", extend)) {
          mixins = [].concat(extend);
          for (i = 0, n = mixins.length; i < n; i++)
            this.extend(mixins[i]);
        }
        if (this.shouldIgnore("include", include)) {
          mixins = [].concat(include);
          for (i = 0, n = mixins.length; i < n; i++)
            this.include(mixins[i], { _resolve: false });
        }
        for (field in module) {
          if (!module.hasOwnProperty(field))
            continue;
          value = module[field];
          if (this.shouldIgnore(field, value))
            continue;
          this.define(field, value, { _resolve: false });
        }
        if (module.hasOwnProperty("toString"))
          this.define("toString", module.toString, { _resolve: false });
      }
      if (resolve)
        this.resolve();
      return this;
    },
    alias: function (aliases) {
      for (var method in aliases) {
        if (!aliases.hasOwnProperty(method))
          continue;
        this.define(method, this.instanceMethod(aliases[method]), { _resolve: false });
      }
      this.resolve();
    },
    resolve: function (host) {
      var host = host || this, target = host.__tgt__, inc = this.__inc__, fns = this.__fns__, i, n, key, compiled;
      if (host === this) {
        this.__anc__ = null;
        this.__mct__ = {};
        i = this.__dep__.length;
        while (i--)
          this.__dep__[i].resolve();
      }
      if (!target)
        return;
      for (i = 0, n = inc.length; i < n; i++)
        inc[i].resolve(host);
      for (key in fns) {
        compiled = JS.Method.compile(fns[key], host);
        if (target[key] !== compiled)
          target[key] = compiled;
      }
      if (fns.hasOwnProperty("toString"))
        target.toString = JS.Method.compile(fns.toString, host);
    },
    shouldIgnore: function (field, value) {
      return (field === "extend" || field === "include") && (typeof value !== "function" || value.__fns__ && value.__inc__);
    },
    ancestors: function (list) {
      var cachable = !list, list = list || [], inc = this.__inc__;
      if (cachable && this.__anc__)
        return this.__anc__.slice();
      for (var i = 0, n = inc.length; i < n; i++)
        inc[i].ancestors(list);
      if (JS.indexOf(list, this) < 0)
        list.push(this);
      if (cachable)
        this.__anc__ = list.slice();
      return list;
    },
    lookup: function (name) {
      var cached = this.__mct__[name];
      if (cached && cached.slice)
        return cached.slice();
      var ancestors = this.ancestors(), methods = [], fns;
      for (var i = 0, n = ancestors.length; i < n; i++) {
        fns = ancestors[i].__fns__;
        if (fns.hasOwnProperty(name))
          methods.push(fns[name]);
      }
      this.__mct__[name] = methods.slice();
      return methods;
    },
    includes: function (module) {
      if (module === this)
        return true;
      var inc = this.__inc__;
      for (var i = 0, n = inc.length; i < n; i++) {
        if (inc[i].includes(module))
          return true;
      }
      return false;
    },
    instanceMethod: function (name) {
      return this.lookup(name).pop();
    },
    instanceMethods: function (recursive, list) {
      var methods = list || [], fns = this.__fns__, field;
      for (field in fns) {
        if (!JS.isType(this.__fns__[field], JS.Method))
          continue;
        if (JS.indexOf(methods, field) >= 0)
          continue;
        methods.push(field);
      }
      if (recursive !== false) {
        var ancestors = this.ancestors(), i = ancestors.length;
        while (i--)
          ancestors[i].instanceMethods(false, methods);
      }
      return methods;
    },
    match: function (object) {
      return object && object.isA && object.isA(this);
    },
    toString: function () {
      return this.displayName;
    }
  });
  JS.Kernel = new JS.Module("Kernel", {
    __eigen__: function () {
      if (this.__meta__)
        return this.__meta__;
      var name = this.toString() + ".";
      this.__meta__ = new JS.Module(name, null, { _target: this });
      return this.__meta__.include(this.klass, { _resolve: false });
    },
    equals: function (other) {
      return this === other;
    },
    extend: function (module, options) {
      var resolve = (options || {})._resolve;
      this.__eigen__().include(module, {
        _extended: this,
        _resolve: resolve
      });
      return this;
    },
    hash: function () {
      return JS.Kernel.hashFor(this);
    },
    isA: function (module) {
      return typeof module === "function" && this instanceof module || this.__eigen__().includes(module);
    },
    method: function (name) {
      var cache = this.__mct__ = this.__mct__ || {}, value = cache[name], field = this[name];
      if (typeof field !== "function")
        return field;
      if (value && field === value._value)
        return value._bound;
      var bound = JS.bind(field, this);
      cache[name] = {
        _value: field,
        _bound: bound
      };
      return bound;
    },
    methods: function () {
      return this.__eigen__().instanceMethods();
    },
    tap: function (block, context) {
      block.call(context, this);
      return this;
    },
    toString: function () {
      if (this.displayName)
        return this.displayName;
      var name = this.klass.displayName || this.klass.toString();
      return "#<" + name + ":" + this.hash() + ">";
    }
  });
  (function () {
    var id = 1;
    JS.Kernel.hashFor = function (object) {
      if (object.__hash__ !== undefined)
        return object.__hash__;
      object.__hash__ = (new JS.Date().getTime() + id).toString(16);
      id += 1;
      return object.__hash__;
    };
  }());
  JS.Class = JS.makeClass(JS.Module);
  JS.extend(JS.Class.prototype, {
    initialize: function (name, parent, methods, options) {
      if (typeof name !== "string") {
        options = arguments[2];
        methods = arguments[1];
        parent = arguments[0];
        name = undefined;
      }
      if (typeof parent !== "function") {
        options = methods;
        methods = parent;
        parent = Object;
      }
      JS.Module.prototype.initialize.call(this, name);
      options = options || {};
      var klass = JS.makeClass(parent);
      JS.extend(klass, this);
      klass.prototype.constructor = klass.prototype.klass = klass;
      klass.__eigen__().include(parent.__meta__, { _resolve: options._resolve });
      klass.setName(name);
      klass.__tgt__ = klass.prototype;
      var parentModule = parent === Object ? {} : parent.__fns__ ? parent : new JS.Module(parent.prototype, { _resolve: false });
      klass.include(JS.Kernel, { _resolve: false }).include(parentModule, { _resolve: false }).include(methods, { _resolve: false });
      if (options._resolve !== false)
        klass.resolve();
      if (typeof parent.inherited === "function")
        parent.inherited(klass);
      return klass;
    }
  });
  (function () {
    var methodsFromPrototype = function (klass) {
      var methods = {}, proto = klass.prototype;
      for (var field in proto) {
        if (!proto.hasOwnProperty(field))
          continue;
        methods[field] = JS.Method.create(klass, field, proto[field]);
      }
      return methods;
    };
    var classify = function (name, parentName) {
      var klass = JS[name], parent = JS[parentName];
      klass.__inc__ = [];
      klass.__dep__ = [];
      klass.__fns__ = methodsFromPrototype(klass);
      klass.__tgt__ = klass.prototype;
      klass.prototype.constructor = klass.prototype.klass = klass;
      JS.extend(klass, JS.Class.prototype);
      klass.include(parent || JS.Kernel);
      klass.setName(name);
      klass.constructor = klass.klass = JS.Class;
    };
    classify("Method");
    classify("Module");
    classify("Class", "Module");
    var eigen = JS.Kernel.instanceMethod("__eigen__");
    eigen.call(JS.Method).resolve();
    eigen.call(JS.Module).resolve();
    eigen.call(JS.Class).include(JS.Module.__meta__);
  }());
  JS.NotImplementedError = new JS.Class("NotImplementedError", Error);
  JS.Method.keyword("callSuper", function (method, env, receiver, args) {
    var methods = env.lookup(method.name), stackIndex = methods.length - 1, params = JS.array(args);
    if (stackIndex === 0)
      return undefined;
    var _super = function () {
      var i = arguments.length;
      while (i--)
        params[i] = arguments[i];
      stackIndex -= 1;
      if (stackIndex === 0)
        delete receiver.callSuper;
      var returnValue = methods[stackIndex].apply(receiver, params);
      receiver.callSuper = _super;
      stackIndex += 1;
      return returnValue;
    };
    return _super;
  });
  JS.Method.keyword("blockGiven", function (method, env, receiver, args) {
    var block = Array.prototype.slice.call(args, method.arity), hasBlock = typeof block[0] === "function";
    return function () {
      return hasBlock;
    };
  });
  JS.Method.keyword("yieldWith", function (method, env, receiver, args) {
    var block = Array.prototype.slice.call(args, method.arity);
    return function () {
      if (typeof block[0] !== "function")
        return;
      return block[0].apply(block[1] || null, arguments);
    };
  });
  JS.Interface = new JS.Class("Interface", {
    initialize: function (methods) {
      this.test = function (object, returnName) {
        var n = methods.length;
        while (n--) {
          if (typeof object[methods[n]] !== "function")
            return returnName ? methods[n] : false;
        }
        return true;
      };
    },
    extend: {
      ensure: function () {
        var args = JS.array(arguments), object = args.shift(), face, result;
        while (face = args.shift()) {
          result = face.test(object, true);
          if (result !== true)
            throw new Error("object does not implement " + result + "()");
        }
      }
    }
  });
  JS.Singleton = new JS.Class("Singleton", {
    initialize: function (name, parent, methods) {
      return new new JS.Class(name, parent, methods)();
    }
  });
  JS.extend(exports, JS);
  if (global.JS)
    JS.extend(global.JS, JS);
}));

return module.exports;

});
define('bpmn/util/Index',['require', 'exports', 'module', './JSClass'], function (require, exports, module, jsclass) {
  

var index = {
    initialize: function () {
      this._ = {};
    },
    add: function (key, value) {
      this._[key] = value;
    },
    addArray: function (key, value) {
      if (!this._[key]) {
        this._[key] = [];
      }
      this._[key].push(value);
    },
    addMap: function (key, property, value) {
      if (!this._[key]) {
        this._[key] = {};
      }
      this._[key][property] = value;
    },
    item: function (key) {
      return this._[key];
    }
  };
  return new jsclass.Class(index);


});
define('bpmn/Clazz',['require', 'exports', 'module', './util/JSClass'], function (require, exports, module, jsclass) {
  

var clazz = {
    initialize: function () {
      this.text = null;
      this.reference = {};
      this.attribute = {};
    },
    addReference: function (ref) {
      this.reference[ref.name] = ref;
      var name = this.__internalFieldName(ref.name);
      if (ref.containment === true) {
        this[name] = [];
      } else {
        this[name] = null;
      }
      this[ref.name] = function (newValue) {
        return this.accessor(ref.name, newValue);
      };
    },
    addAttribute: function (attr) {
      this.attribute[attr.name] = attr;
      this[attr.name] = function (newValue) {
        return this.accessor(attr.name, newValue);
      };
    },
    accessor: function (field, newValue) {
      var name = this.__internalFieldName(field);
      if (newValue != null && newValue != undefined) {
        this[name] = newValue;
      }
      return this[name];
    },
    __internalFieldName: function (field) {
      return "_" + field;
    },
    init: function () {
    },
    setText: function (text) {
      this.text = text;
    }
  };
  return new jsclass.Class(clazz);


});
define('bpmn/BaseElement',['require', 'exports', 'module', './util/JSClass', './Clazz'], function (require, exports, module, jsclass, Clazz) {
  

var baseElement = {
    tag: "baseElement",
    initialize: function () {
      this.callSuper();
      this.addReference({
        name: "documentation",
        type: function Documentation() {
        }
      });
      this.addAttribute({
        name: "id",
        type: String
      });
      this.addAttribute({
        name: "name",
        type: String
      });
      var uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
      this.id(uuid);
    },
    init: function () {
      var id = this.id();
      this._definitions.index.add(id, this);
      this._definitions.index.addMap(this.declaredClass, id, this);
    }
  };
  return new jsclass.Class(Clazz, baseElement);


});
define('bpmn/CallableElement',['require', 'exports', 'module', './util/JSClass', './BaseElement'], function (require, exports, module, jsclass, BaseElement) {
  

var callableElement = {
    initialize: function () {
      this.callSuper();
      this.addAttribute({
        name: "name",
        type: String
      });
    },
    init: function () {
      this.callSuper();
    }
  };
  return new jsclass.Class(BaseElement, callableElement);


});
define('bpmn/Package',['require', 'exports', 'module', './util/JSClass'], function (require, exports, module, jsclass) {
  

var packageDef = {
    tagMap: {},
    initialize: function () {
    },
    registerClass: function (newClass) {
      var tag = newClass.prototype.tag;
      if (tag) {
        this.tagMap[tag.toLowerCase()] = newClass;
      }
      return newClass;
    }
  };
  var Package = new jsclass.Class(packageDef);
  return new Package();


});
define('bpmn/FlowElement',['require', 'exports', 'module', './util/JSClass', './BaseElement', './Package'], function (require, exports, module, jsclass, BaseElement, Package) {
  

var flowElement = {
    tag: "flowElement",
    initialize: function () {
      this.callSuper();
    },
    init: function () {
      this.callSuper();
    },
    getDiagramElement: function () {
      return this._definitions.index.item(this.id() + ":di");
    },
    getBounds: function () {
      return this.getDiagramElement().bounds();
    },
    getLabel: function () {
      return this.getDiagramElement().label();
    },
    getWaypoints: function () {
      return this.getDiagramElement().waypoints();
    }
  };
  var FlowElementClass = new jsclass.Class(BaseElement, flowElement);
  Package.registerClass(FlowElementClass);
  return FlowElementClass;


});
define('bpmn/FlowElementsContainer',['require', 'exports', 'module', './util/JSClass', './BaseElement', './FlowElement'], function (require, exports, module, jsclass, BaseElement, FlowElement) {
  

var flowElementsContainer = {
    initialize: function () {
      this.callSuper();
      this.addReference({
        name: "flowElements",
        containment: true,
        type: FlowElement
      });
    },
    init: function () {
      this.callSuper();
    }
  };
  return new jsclass.Module(flowElementsContainer);


});
define('bpmn/Process',['require', 'exports', 'module', './util/JSClass', './CallableElement', './FlowElementsContainer', './Package'], function (require, exports, module, jsclass, CallableElement, FlowElementsContainer, Package) {
  

var process = {
    include: [FlowElementsContainer],
    tag: "process",
    initialize: function () {
      this.callSuper();
      this.addAttribute({
        name: "isExecutable",
        type: "boolean"
      });
      this.addAttribute({
        name: "name",
        type: String
      });
    }
  };
  var processClass = new jsclass.Class(CallableElement, process);
  return Package.registerClass(processClass);


});
define('bpmn/Collaboration',['require', 'exports', 'module', './util/JSClass', './Package'], function (require, exports, module, jsclass, Package) {
  

var collaboration = {
    tag: "collaboration",
    initialize: function () {
    }
  };
  var CollaborationClass = new jsclass.Class(collaboration);
  Package.registerClass(CollaborationClass);
  return CollaborationClass;


});
define('bpmn/di/DiagramElement',['require', 'exports', 'module', '../util/JSClass', '../Clazz', '../Package'], function (require, exports, module, jsclass, Clazz, Package) {
  

var DiagramElement = {
    tag: "diagramElement",
    initialize: function () {
      this.callSuper();
      this.addAttribute({
        name: "id",
        type: String
      });
      this.addAttribute({
        name: "bpmnElement",
        type: String
      });
    },
    init: function () {
      this._definitions.index.add(this.bpmnElement() + ":di", this);
    }
  };
  var DiagramElementClass = new jsclass.Class(Clazz, DiagramElement);
  Package.registerClass(DiagramElementClass);
  return DiagramElementClass;


});
define('bpmn/di/Bounds',['require', 'exports', 'module', '../util/JSClass', '../Clazz', '../Package'], function (require, exports, module, jsclass, Clazz, Package) {
  

var Bounds = {
    tag: "Bounds",
    initialize: function () {
      this.callSuper();
      this.addAttribute({
        name: "x",
        type: "float"
      });
      this.addAttribute({
        name: "y",
        type: "float"
      });
      this.addAttribute({
        name: "width",
        type: "float"
      });
      this.addAttribute({
        name: "height",
        type: "float"
      });
    },
    init: function () {
      this.callSuper();
    }
  };
  var BoundsClass = new jsclass.Class(Clazz, Bounds);
  Package.registerClass(BoundsClass);
  return BoundsClass;


});
define('bpmn/di/BPMNLabel',['require', 'exports', 'module', '../util/JSClass', '../Clazz', '../Package', './Bounds'], function (require, exports, module, jsclass, Clazz, Package, Bounds) {
  

var BPMNLabel = {
    tag: "BPMNLabel",
    initialize: function () {
      this.callSuper();
      this.addReference({
        name: "bounds",
        type: Bounds
      });
    },
    init: function () {
      this.callSuper();
    }
  };
  var BPMNLabelClass = new jsclass.Class(Clazz, BPMNLabel);
  Package.registerClass(BPMNLabelClass);
  return BPMNLabelClass;


});
define('bpmn/di/BPMNShape',['require', 'exports', 'module', '../util/JSClass', './DiagramElement', './Bounds', './BPMNLabel', '../Package'], function (require, exports, module, jsclass, DiagramElement, Bounds, BPMNLabel, Package) {
  

var BPMNShape = {
    tag: "BPMNShape",
    initialize: function () {
      this.callSuper();
      this.addReference({
        name: "bounds",
        type: Bounds
      });
      this.addReference({
        name: "label",
        type: BPMNLabel
      });
    },
    init: function () {
      this.callSuper();
    }
  };
  var BPMNShapeClass = new jsclass.Class(DiagramElement, BPMNShape);
  Package.registerClass(BPMNShapeClass);
  return BPMNShapeClass;


});
define('bpmn/di/Waypoint',['require', 'exports', 'module', '../util/JSClass', '../Clazz', '../Package'], function (require, exports, module, jsclass, Clazz, Package) {
  

var Waypoint = {
    tag: "waypoint",
    initialize: function () {
      this.callSuper();
      this.addAttribute({
        name: "x",
        type: "float"
      });
      this.addAttribute({
        name: "y",
        type: "float"
      });
    },
    init: function () {
      this.callSuper();
    },
    __internalFieldName: function (field) {
      return field;
    }
  };
  var WaypointClass = new jsclass.Class(Clazz, Waypoint);
  Package.registerClass(WaypointClass);
  return WaypointClass;


});
define('bpmn/di/BPMNEdge',['require', 'exports', 'module', '../util/JSClass', './DiagramElement', './Waypoint', '../Package'], function (require, exports, module, jsclass, DiagramElement, Waypoint, Package) {
  

var BPMNEdge = {
    tag: "BPMNEdge",
    initialize: function () {
      this.callSuper();
      this.addReference({
        name: "waypoints",
        containment: true,
        type: Waypoint
      });
    },
    init: function () {
      this.callSuper();
    }
  };
  var BPMNEdgeClass = new jsclass.Class(DiagramElement, BPMNEdge);
  Package.registerClass(BPMNEdgeClass);
  return BPMNEdgeClass;


});
define('bpmn/di/BPMNPlane',['require', 'exports', 'module', '../util/JSClass', '../Clazz', '../Package', './BPMNShape', './BPMNEdge', './DiagramElement'], function (require, exports, module, jsclass, Clazz, Package, Shape, Edge, DiagramElement) {
  

var BPMNPlane = {
    tag: "BPMNPlane",
    initialize: function () {
      this.callSuper();
      this.addReference({
        name: "diagramElements",
        containment: true,
        type: DiagramElement
      });
    },
    init: function () {
      this.callSuper();
    }
  };
  var BPMNPlaneClass = new jsclass.Class(Clazz, BPMNPlane);
  Package.registerClass(BPMNPlaneClass);
  return BPMNPlaneClass;


});
define('bpmn/di/BPMNDiagram',['require', 'exports', 'module', '../util/JSClass', '../Clazz', './BPMNPlane', '../Package'], function (require, exports, module, jsclass, Clazz, BPMNPlane, Package) {
  

var BPMNDiagram = {
    tag: "BPMNDiagram",
    initialize: function () {
      this.callSuper();
      this.addReference({
        name: "plane",
        type: BPMNPlane
      });
    }
  };
  var BPMNDiagramClass = new jsclass.Class(Clazz, BPMNDiagram);
  Package.registerClass(BPMNDiagramClass);
  return BPMNDiagramClass;


});
define('bpmn/FlowNode',['require', 'exports', 'module', './util/JSClass', './FlowElement', './Package'], function (require, exports, module, jsclass, FlowElement, Package) {
  

var flowNode = {
    tag: "flowNode",
    initialize: function () {
      this.callSuper();
    },
    init: function () {
      this.callSuper();
    },
    incoming: function () {
      var incoming = this._definitions.index.item("target:" + this.id());
      return incoming ? incoming : [];
    },
    outgoing: function () {
      var outgoing = this._definitions.index.item("source:" + this.id());
      return outgoing ? outgoing : [];
    }
  };
  var FlowNodeClass = new jsclass.Class(FlowElement, flowNode);
  Package.registerClass(FlowNodeClass);
  return FlowNodeClass;


});
define('bpmn/Event',['require', 'exports', 'module', './util/JSClass', './FlowNode', './Package'], function (require, exports, module, jsclass, FlowNode, Package) {
  

var event = {
    tag: "event",
    initialize: function () {
      this.callSuper();
    },
    init: function () {
      this.callSuper();
    }
  };
  var EventClass = new jsclass.Class(FlowNode, event);
  Package.registerClass(EventClass);
  return EventClass;


});
define('bpmn/CatchEvent',['require', 'exports', 'module', './util/JSClass', './Event', './Package'], function (require, exports, module, jsclass, Event, Package) {
  

var catchEvent = {
    tag: "catchEvent",
    initialize: function () {
      this.callSuper();
    },
    init: function () {
      this.callSuper();
    }
  };
  var CatchEventClass = new jsclass.Class(Event, catchEvent);
  Package.registerClass(CatchEventClass);
  return CatchEventClass;


});
define('bpmn/StartEvent',['require', 'exports', 'module', './util/JSClass', './CatchEvent', './Package'], function (require, exports, module, jsclass, CatchEvent, Package) {
  

var startEvent = {
    tag: "startEvent",
    initialize: function () {
      this.callSuper();
    },
    init: function () {
      this.callSuper();
    }
  };
  var StartEventClass = new jsclass.Class(CatchEvent, startEvent);
  Package.registerClass(StartEventClass);
  return StartEventClass;


});
define('bpmn/ThrowEvent',['require', 'exports', 'module', './util/JSClass', './Event', './Package'], function (require, exports, module, jsclass, Event, Package) {
  

var throwEvent = {
    tag: "throwEvent",
    initialize: function () {
      this.callSuper();
    },
    init: function () {
      this.callSuper();
    }
  };
  var ThrowEventClass = new jsclass.Class(Event, throwEvent);
  Package.registerClass(ThrowEventClass);
  return ThrowEventClass;


});
define('bpmn/EndEvent',['require', 'exports', 'module', './util/JSClass', './ThrowEvent', './Package'], function (require, exports, module, jsclass, ThrowEvent, Package) {
  

var endEvent = {
    tag: "endEvent",
    initialize: function () {
      this.callSuper();
    },
    init: function () {
      this.callSuper();
    }
  };
  var EndEventClass = new jsclass.Class(ThrowEvent, endEvent);
  Package.registerClass(EndEventClass);
  return EndEventClass;


});
define('bpmn/BoundaryEvent',['require', 'exports', 'module', './util/JSClass', './CatchEvent', './Package'], function (require, exports, module, jsclass, CatchEvent, Package) {
  

var boundaryEvent = {
    tag: "boundaryEvent",
    initialize: function () {
      this.callSuper();
    },
    init: function () {
      this.callSuper();
    }
  };
  var BoundaryEventClass = new jsclass.Class(CatchEvent, boundaryEvent);
  Package.registerClass(BoundaryEventClass);
  return BoundaryEventClass;


});
define('bpmn/Activity',['require', 'exports', 'module', './util/JSClass', './FlowNode', './Package'], function (require, exports, module, jsclass, FlowNode, Package) {
  

var activity = {
    tag: "activity",
    initialize: function () {
      this.callSuper();
    },
    init: function () {
      this.callSuper();
    }
  };
  var ActivityClass = new jsclass.Class(FlowNode, activity);
  Package.registerClass(ActivityClass);
  return ActivityClass;


});
define('bpmn/Task',['require', 'exports', 'module', './util/JSClass', './Activity', './Package'], function (require, exports, module, jsclass, Activity, Package) {
  

var task = {
    tag: "task",
    initialize: function () {
      this.callSuper();
    },
    init: function () {
      this.callSuper();
    }
  };
  var TaskClass = new jsclass.Class(Activity, task);
  Package.registerClass(TaskClass);
  return TaskClass;


});
define('bpmn/UserTask',['require', 'exports', 'module', './util/JSClass', './Task', './Package'], function (require, exports, module, jsclass, Task, Package) {
  

var userTask = {
    tag: "userTask",
    initialize: function () {
      this.callSuper();
    },
    init: function () {
      this.callSuper();
    }
  };
  var UserTaskClass = new jsclass.Class(Task, userTask);
  Package.registerClass(UserTaskClass);
  return UserTaskClass;


});
define('bpmn/ServiceTask',['require', 'exports', 'module', './util/JSClass', './Task', './Package'], function (require, exports, module, jsclass, Task, Package) {
  

var serviceTask = {
    tag: "serviceTask",
    initialize: function () {
      this.callSuper();
    },
    init: function () {
      this.callSuper();
    }
  };
  var ServiceTaskClass = new jsclass.Class(Task, serviceTask);
  Package.registerClass(ServiceTaskClass);
  return ServiceTaskClass;


});
define('bpmn/BusinessRuleTask',['require', 'exports', 'module', './util/JSClass', './Task', './Package'], function (require, exports, module, jsclass, Task, Package) {
  

var businessRuleTask = {
    tag: "businessRuleTask",
    initialize: function () {
      this.callSuper();
    },
    init: function () {
      this.callSuper();
    }
  };
  var BusinessRuleTaskClass = new jsclass.Class(Task, businessRuleTask);
  Package.registerClass(BusinessRuleTaskClass);
  return BusinessRuleTaskClass;


});
define('bpmn/ReceiveTask',['require', 'exports', 'module', './util/JSClass', './Task', './Package'], function (require, exports, module, jsclass, Task, Package) {
  

var receiveTask = {
    tag: "receiveTask",
    initialize: function () {
      this.callSuper();
    },
    init: function () {
      this.callSuper();
    }
  };
  var ReceiveTaskClass = new jsclass.Class(Task, receiveTask);
  Package.registerClass(ReceiveTaskClass);
  return ReceiveTaskClass;


});
define('bpmn/SubProcess',['require', 'exports', 'module', './util/JSClass', './Activity', './FlowElementsContainer', './Package'], function (require, exports, module, jsclass, Activity, FlowElementsContainer, Package) {
  

var subProcess = {
    include: [FlowElementsContainer],
    tag: "subProcess",
    initialize: function () {
      this.callSuper();
    },
    init: function () {
      this.callSuper();
    }
  };
  var SubProcessClass = new jsclass.Class(Activity, subProcess);
  Package.registerClass(SubProcessClass);
  return SubProcessClass;


});
define('bpmn/Gateway',['require', 'exports', 'module', './util/JSClass', './FlowNode', './Package'], function (require, exports, module, jsclass, FlowNode, Package) {
  

var gateway = {
    tag: "gateway",
    initialize: function () {
      this.callSuper();
    },
    init: function () {
      this.callSuper();
    }
  };
  var GatewayClass = new jsclass.Class(FlowNode, gateway);
  Package.registerClass(GatewayClass);
  return GatewayClass;


});
define('bpmn/ExclusiveGateway',['require', 'exports', 'module', './util/JSClass', './Gateway', './Package'], function (require, exports, module, jsclass, Gateway, Package) {
  

var exclusiveGateway = {
    tag: "exclusiveGateway",
    initialize: function () {
      this.callSuper();
    },
    init: function () {
      this.callSuper();
    }
  };
  var ExclusiveGateway = new jsclass.Class(Gateway, exclusiveGateway);
  Package.registerClass(ExclusiveGateway);
  return ExclusiveGateway;


});
define('bpmn/ParallelGateway',['require', 'exports', 'module', './util/JSClass', './Gateway', './Package'], function (require, exports, module, jsclass, Gateway, Package) {
  

var parallelGateway = {
    tag: "parallelGateway",
    initialize: function () {
      this.callSuper();
    },
    init: function () {
      this.callSuper();
    }
  };
  var ParallelGatewayClass = new jsclass.Class(Gateway, parallelGateway);
  Package.registerClass(ParallelGatewayClass);
  return ParallelGatewayClass;


});
define('bpmn/ConditionExpression',['require', 'exports', 'module', './util/JSClass', './BaseElement', './Package'], function (require, exports, module, jsclass, BaseElement, Package) {
  

var conditionExpression = {
    tag: "conditionExpression",
    initialize: function () {
      this.callSuper();
    },
    init: function () {
      this.callSuper();
    }
  };
  var ConditionExpressionClass = new jsclass.Class(BaseElement, conditionExpression);
  Package.registerClass(ConditionExpressionClass);
  return ConditionExpressionClass;


});
define('bpmn/SequenceFlow',['require', 'exports', 'module', './util/JSClass', './FlowElement', './ConditionExpression', './Package'], function (require, exports, module, jsclass, FlowElement, ConditionExpression, Package) {
  

var sequenceFlow = {
    tag: "sequenceFlow",
    initialize: function () {
      this.callSuper();
      this.addAttribute({
        name: "sourceRef",
        type: String
      });
      this.addAttribute({
        name: "targetRef",
        type: String
      });
      this.addReference({
        name: "conditionExpression",
        type: ConditionExpression
      });
    },
    getSourceRef: function () {
      return this._definitions.index.item(this._sourceRef);
    },
    getTargetRef: function () {
      return this._definitions.index.item(this._targetRef);
    },
    init: function () {
      this.callSuper();
      if (!this._definitions.index.addArray) {
        console.log("cant addArray" + this.id());
        console.log(this._definitions.index.tag);
      }
      this._definitions.index.addArray("target:" + this.targetRef(), this);
      this._definitions.index.addArray("source:" + this.sourceRef(), this);
    }
  };
  var SequenceFlowClass = new jsclass.Class(FlowElement, sequenceFlow);
  Package.registerClass(SequenceFlowClass);
  return SequenceFlowClass;


});
define('bpmn/Definitions',['require', 'exports', 'module', './util/JSClass', './util/Index', './BaseElement', './Process', './Collaboration', './di/BPMNDiagram', './StartEvent', './EndEvent', './BoundaryEvent', './UserTask', './ServiceTask', './BusinessRuleTask', './ReceiveTask', './SubProcess', './ExclusiveGateway', './ParallelGateway', './SequenceFlow'], function (require, exports, module, jsclass, Index, BaseElement, Process, Collaboration, BPMNDiagram) {
  

var definitions = {
    tag: "definitions",
    initialize: function () {
      this.callSuper();
      this.addReference({
        name: "collaboration",
        type: Collaboration
      });
      this.addReference({
        name: "process",
        containment: true,
        type: Process
      });
      this.addReference({
        name: "bpmnDiagram",
        type: BPMNDiagram
      });
      this.index = new Index();
    }
  };
  return new jsclass.Class(BaseElement, definitions);


});
define('bpmn/execution/TokenStore',['require', 'exports', 'module', '../util/JSClass'], function (require, exports, module, jsclass) {
  

var tokenStore = {
    initialize: function (tokenMap) {
      this.tokenMap = tokenMap ? tokenMap : {};
    },
    add: function (id, token) {
      if (!this.tokenMap[id]) {
        this.tokenMap[id] = [];
      }
      this.tokenMap[id].push(token);
    },
    drop: function (id, count) {
      if (this.tokenMap[id]) {
        for (var c = 0; c < count; c++) {
          this.tokenMap[id].pop();
        }
      }
    },
    query: function (id) {
      return this.tokenMap[id] ? this.tokenMap[id] : [];
    },
    count: function () {
      var result = 0;
      for (var key in this.tokenMap) {
        result += this.tokenMap[key].length;
      }
      return result;
    }
  };
  return new jsclass.Class(tokenStore);


});
define('lodash',[],function () {
  if (__isNode) {
  return __nodeRequire('lodash');
} else {
    return (typeof _ !== 'undefined') ? _ : __throwMissing('lodash', '_')
}
});
define('q',[],function () {
  if (__isNode) {
  return __nodeRequire('q');
} else {
    return (typeof Q !== 'undefined') ? Q : __throwMissing('q', 'Q')
}
});
define('bpmn/util/Topic',['require', 'exports', 'module', './JSClass'], function (require, exports, module, jsclass) {
  

var topic = {
    publish: function (eventPath, message) {
    }
  };
  return new jsclass.Class(topic);


});
define('bpmn/execution/Instance',['require', 'exports', 'module', './TokenStore', '../util/JSClass', 'lodash', 'q', '../util/Topic'], function (require, exports, module, TokenStore, jsclass, _, Q, Topic) {
  

var instance = {
    initialize: function (definitions, configuration, tokenMap, variables) {
      this.definitions = definitions;
      this.configuration = configuration || {};
      this.tokenStore = new TokenStore(tokenMap);
      this.variables = variables ? variables : {};
      this.topic = new Topic();
      this.behaviours["startEvent"] = this.behaviours["takeAll"];
      this.behaviours["endEvent"] = this.behaviours["takeNone"];
      this.behaviours["userTask"] = this.behaviours["takeNone"];
      this.behaviours["serviceTask"] = this.behaviours["takeAll"];
      this.behaviours["task"] = this.behaviours["takeAll"];
      this.behaviours["exclusiveGateway"] = this.behaviours["xor"];
      this.behaviours["parallelGateway"] = this.behaviours["and"];
    },
    behaviours: {
      "takeAll": function (element) {
        this.dropToken(element.id(), this.tokenStore);
        return element.outgoing();
      },
      "takeNone": function (element) {
        return [];
      },
      "xor": function (element) {
        this.dropToken(element.id(), this.tokenStore);
        if (element.outgoing().length == 1) {
          return element.outgoing();
        }
        var transition = null;
        _.map(element.outgoing(), function (outgoing) {
          var flowConfig = this.configuration[outgoing.id()];
          if (!transition && flowConfig && flowConfig(this)) {
            transition = outgoing;
          }
        }, this);
        if (!transition && !element.getDefault()) {
          throw new Error("No transition evaluated to true and no default defined");
        }
        return transition;
      },
      "and": function (element) {
        var isActive = true;
        var tokens = this.tokenStore.query(element.id());
        var fromMap = {};
        if (element.incoming().length == 1) {
          return _.bind(this.behaviours.takeAll, this)(element);
        }
        for (var index = 0; index < tokens.length; index++) {
          var token = tokens[index];
          fromMap[token.from] = token;
        }
        var activeTransitions = [];
        _.map(element.incoming(), function (incoming) {
          if (!fromMap[incoming.id()]) {
            isActive = false;
          } else {
            activeTransitions.push(incoming);
          }
        }, this);
        if (isActive) {
          _.map(activeTransitions, function (t) {
            _.bind(this.dropToken, this)(t.sourceRef(), this.tokenStore);
          }, this);
          return _.bind(this.behaviours.takeAll, this)(element);
        } else {
          return [];
        }
      }
    },
    dropToken: function (id, tokenStore, count) {
      if (tokenStore.query(id).length > 0) {
        tokenStore.drop(id, count ? count : 1);
      }
    },
    copyVariables: function (variables) {
      if (variables) {
        for (var index in variables) {
          this.variables[index] = variables[index];
        }
      }
    },
    start: function (startId, variables) {
      this.tokenStore.add(startId, { from: null });
      return this.trigger(startId, variables);
    },
    trigger: function (elementId, variables, behaviour, path) {
      console.log("trigger", elementId);
      var deferred = Q.defer();
      var path = path ? path : Q.defer();
      this.copyVariables(variables);
      var node = this.definitions.index.item(elementId);
      var nodeBehaviour = behaviour ? this.behaviours[behaviour] : this.behaviours[node.tag];
      console.log("nodeBehaviour", nodeBehaviour);
      var transitions = [].concat(_.bind(nodeBehaviour, this)(node, this.tokenStore));
      console.log("next", transitions);
      if (transitions.length > 0 && this.configuration.leave) {
        this.configuration.leave(node);
        this.topic.publish("flow:leave:" + node.id(), node);
      }
      if (transitions.length == 0) {
        path.resolve();
      }
      transitions.map(function (transition) {
        this.tokenStore.add(transition.targetRef(), { from: transition.id() });
        var pubPath = "flow:enter:" + transition.targetRef();
        this.topic.publish(pubPath, transition.getTargetRef());
        if (this.configuration.enter) {
          this.configuration.enter(transition.getTargetRef());
        }
        var self = this;
        deferred.promise.then(function () {
          console.log("then for", transition.id());
          self.trigger(transition.targetRef(), null, null, path);
        });
      }, this);
      if (this.configuration[elementId] && this.configuration[elementId]) {
        this.configuration[elementId]({
          instance: this,
          promise: deferred
        });
      } else {
        console.log("resolving", elementId, this.tokenStore.tokenMap);
        deferred.resolve();
      }
      return path.promise;
    }
  };
  return new jsclass.Class(instance);


});
define('sax',[],function () {
  if (__isNode) {
  return __nodeRequire('sax');
} else {
    return (typeof sax !== 'undefined') ? sax : __throwMissing('sax', 'sax')
}
});
define('bpmn/util/Serializer',['require', 'exports', 'module', './JSClass', '../Package', '../Definitions', '../BaseElement', 'sax'], function (require, exports, module, jsclass, Package, Definitions, BaseElement) {
  

var serializer = {
    initialize: function () {
    },
    fromXML: function (xmlString) {
      if (!xmlString) {
        return;
      }
      var setAttributeFromNode = function (attrName, node, bpmnObj, type) {
        if (node.attributes[attrName]) {
          var value = node.attributes[attrName].value;
          if (type == "float") {
            value = parseFloat(value);
          }
          if (type == "boolean") {
            value = value.toLowerCase() == "true";
          }
          if (type == "integer") {
            value = parseInt(value);
          }
          bpmnObj[attrName](value);
        }
      };
      var parser = sax.parser(true, {
        xmlns: true,
        lowercase: true,
        trim: true
      });
      parser.stack = [];
      Array.prototype.peek = function () {
        return this.length == 0 ? null : this[this.length - 1];
      };
      var openTagHandlers = {
        "definitions": function (node) {
          parser.definitions = new Definitions();
          parser.stack.push(parser.definitions);
        },
        "default": function (node) {
          var parent = parser.stack.peek();
          var tagLookup = node.local.toLowerCase();
          var PackageClass = Package.tagMap[tagLookup];
          var newRef = PackageClass ? new PackageClass() : new BaseElement();
          parser.stack.push(newRef);
          newRef._definitions = parser.definitions;
          for (var attributeName in newRef.attribute) {
            setAttributeFromNode(attributeName, node, newRef, newRef.attribute[attributeName].type);
          }
          var refFound = null;
          for (var index in parent.reference) {
            var ref = parent.reference[index];
            if (newRef.isA(ref.type)) {
              refFound = ref;
              break;
            }
          }
          newRef.init();
          if (refFound && refFound.containment === true) {
            parent[refFound.name]().push(newRef);
          } else if (refFound) {
            parent[refFound.name](newRef);
          }
        }
      };
      parser.onerror = function (e) {
        console.log("error", e);
      };
      parser.onopentag = function (node) {
        if (openTagHandlers[node.local]) {
          openTagHandlers[node.local](node);
        } else {
          openTagHandlers["default"](node);
        }
      };
      parser.onclosetag = function (node) {
        parser.stack.pop();
      };
      parser.ontext = function (t) {
        parser.stack.peek().setText(t);
      };
      parser.onend = function () {
      };
      parser.write(xmlString).close();
      return parser.definitions;
    }
  };
  return new jsclass.Class(serializer);


});
define('bpmn/Bpmn',['require', 'exports', 'module', './util/JSClass', './Definitions', './execution/Instance', './util/Serializer'], function (require, exports, module, jsclass, Definitions, Instance, Serializer) {
  

var bpmn = {
    initialize: function () {
      this.serializer = new Serializer();
    },
    fromXML: function (bpmnXml) {
      return this.serializer.fromXML(bpmnXml);
    },
    instance: function (definitions, configuration) {
      return new Instance(definitions, configuration);
    }
  };
  var bpmnClass = new jsclass.Class(bpmn);
  window.Bpmn = bpmnClass;
  return bpmnClass;


});
    return require('bpmn/Bpmn');

};
if (__isAMD) {
  return define(['lodash', 'q', 'sax', 'jquery'], bundleFactory);
} else {
    if (__isNode) {
        return module.exports = bundleFactory(require('lodash'), require('q'), require('sax'), require('jquery'));
    } else {
        return bundleFactory((typeof _ !== 'undefined') ? _ : __throwMissing('lodash', '_'), (typeof Q !== 'undefined') ? Q : __throwMissing('q', 'Q'), (typeof sax !== 'undefined') ? sax : __throwMissing('sax', 'sax'), (typeof $ !== 'undefined') ? $ : __throwMissing('jquery', '$'));
    }
}
}).call(this, (typeof exports === 'object' || typeof window === 'undefined' ? global : window),
              (typeof exports === 'object' || typeof window === 'undefined' ? global : window))